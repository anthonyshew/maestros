
export default [
  {
    "title": "Credits",
    "ogDescription": "Monorepo Maestros would like to thank...",
    "path": "credits",
    "content": "[Anthony Shew](https://shew.dev), creator of Monorepo Maestros, would like to thank the open source and developer education communities. This resource would not be possible without...\n\n- Anyone with a contribution to something listed in the `package.json` of this project\n- [shadcn](https://twitter.com/shadcn) (Yes, I'm using [ShadUI](https://ui.shadcn.com) just like everyone else.)\n- [Joel Hooks](https://twitter.com/jhooks) for encouraging me to take the leap to build something\n- Folks that are kind of enough to early review the content that I write\n- The [Turborepo](https://turbo.build) Core team and its community contributors\n- The [Next.js](https://nextjs.org) Core team and its community contributors\n- [Contentlayer](https://www.contentlayer.dev/) for making MDX into a TypeScript friendly tool\n- [Vercel](https://vercel.com) for making this project easy to deploy\n- and many more!\n\nDon't see yourself here and think you should be? Let me know. (Yes, I'm serious.)",
    "_meta": {
      "filePath": "landings/credits.mdx",
      "fileName": "credits.mdx",
      "directory": "landings",
      "extension": "mdx",
      "path": "landings/credits"
    }
  },
  {
    "title": "Examples",
    "ogDescription": "A collection of great monorepos to check out.",
    "path": "examples",
    "content": "There are many glowing examples of excellent monorepos out there. Here are a few:\n\n- [This project!](https://github.com/anthonyshew/maestros)\n- [tRPC](https://github.com/trpc/trpc/tree/main)\n- [Vercel Storage](https://github.com/vercel/storage)\n- [Gitmoji](https://github.com/carloscuesta/gitmoji/tree/master)\n- [Turborepo official Examples](https://github.com/vercel/turbo/tree/main/examples)",
    "_meta": {
      "filePath": "landings/examples.mdx",
      "fileName": "examples.mdx",
      "directory": "landings",
      "extension": "mdx",
      "path": "landings/examples"
    }
  },
  {
    "title": "Glossary",
    "ogTitle": "Monorepo Glossary",
    "ogDescription": "A collection of great monorepos to check out.",
    "path": "glossary",
    "content": "## Application\n\nThe [Workspaces](#workspace) of our monorepo that we will deploy. Applications are likely to consume other packages within our monorepo to take advantage of code reuse.\n\n## Atomic\n\nA characteristic of a system where changes are \"all or nothing\". An \"atomic\" system can never end up in a \"halfway\" state. If a change to the system is started, it either fully completes or returns to the starting state.\n\n## Monorepo\n\n[See the Understanding Monorepos page.](/monorepos/understanding-monorepos) This is the opposite of a [polyrepo](#polyrepo).\n\n## Package\n\nA self-contained code module in a monorepo to be used in other packages and applications. We use [Workspaces](#workspace) to define where packages exist in our monorepo.\n\n## Polyrepo\n\nCreating many different code repositories for your code. This is the opposite of a [monorepo](#monorepo).\n\n## Workspace\n\n[See the Workspaces page.](/monorepos/basics/workspaces)\n\n## Yolorepo\n\nA monorepo that doesn't follow many of the rules laid out in this course. In a yolorepo, workspaces borrow code through pathing outside of their workspace boundaries, tasks use configuration from the root of the repository, and there aren't clear boxes drawn around workspaces.\n\nTooling becomes difficult to use. Tasks run way too slow compared to their potential. Making any serious changes in the repository _hurts a lot_. You're constantly battling your formatting and linting configurations.\n\nYou're in a yolorepo.",
    "_meta": {
      "filePath": "landings/glossary.mdx",
      "fileName": "glossary.mdx",
      "directory": "landings",
      "extension": "mdx",
      "path": "landings/glossary"
    }
  },
  {
    "title": "Motivation",
    "ogDescription": "Why did we make this reference?",
    "path": "motivation",
    "content": "Hi, [I'm Anthony](https://shew.dev) and I wanted to take a quick moment to tell you why I created this resource. There are several reasons that I'll list here in no particular order.\n\n## Monorepos are a better way to build software\n\nIf you know me well enough, it's extremely rare that I speak in absolutes. But this is a principle that I'll stand by much more closely than nearly all of my other software opinions.\n\nHandling the responsiblities of Turbo DX at Vercel, I get to work with individuals, startups, and enterprises that are trying to ship their products quickly, safely, and with high-performance.\n\nTo put it simply, I've consistently watched monorepos outperform any other CI/CD, code organization, and deployment strategy. In the past, monorepo tooling wasn't good enough to keep pace with developers. But, today, the tooling is catching up and the results are showing.\n\nDoes this mean a monorepo is a golden bullet in any and all cases? No, probably not. But I'd say it's the 90% case.\n\n## The Chosen One\n\nThere are many resources out there talking about monorepos - but it's hard to get all of the information in one place.\n\nSometimes, they'll tell you why you should use monorepo, leaving you to figure out how to create and implement the details.\n\nSometimes, they'll describe an incredibly in-depth specific technical problem and solution set - but what about the rest of your repo?\n\nSometimes, they'll simply link you to sets of opaque documentation that don't really help you all that much unless you already have several layers of existing knowledge.\n\n**I want Maestros to be The Chosen One**. A place where we have everything we need to create healthy repositories that **ship**. We'll mix fundamental knowledge with links to specific pieces of documentation and then build a practical example.\n\n## Monorepos are misunderstood\n\nDespite being (what I think is) a better way to work, I find that there's a lot of opportunity out there for folks to have a better understanding of monorepos. Often, folks don't realize that a monorepo really is a great option for their use case.\n\nI think this goes back to the previous point. With better resources available, we can unlock better workflows in our monorepos and ship better.\n\n## You need it\n\nIf you're like me, you've looked for am opinionated resource about how to build a monorepo from the ground up and...well, didn't find one. Monorepo Maestros is for you.\n\n## I need it\n\nI'll be real with you: I was finding myself making the same explanations over and over again. Whether it was \"How do I ESLint?\" all the way to incredibly specific enterprise use cases, I love helping people with their monorepos.\n\nBut I want to be more effective with my time. Instead of writing the explanation many times whenever the question comes up, I can write it once and point people here. And, hopefully, I'll be able to iterate on my",
    "_meta": {
      "filePath": "landings/motivation.mdx",
      "fileName": "motivation.mdx",
      "directory": "landings",
      "extension": "mdx",
      "path": "landings/motivation"
    }
  },
  {
    "title": "The basics",
    "sidebarOrderPosition": 2,
    "ogDescription": "The basics of a monorepo.",
    "content": "Before we get our hands dirty, let's take a second to get familiar with the mental model of a monorepo.\n\n<Img\n  srcLight=\"/images/maestros/repo-shape-light.png\"\n  srcDark=\"/images/maestros/repo-shape-dark.png\"\n  containerClassName=\"flex flex-col\"\n/>\n\n## One repo to rule them all\n\nIn a monorepo, we're building one repository that handles all of our applications. However, this doesn't mean we want to think of our monorepo as one giant chunk of code.\n\n## Workspaces are like mini-projects\n\nEvery application and package that you build will be in its own workspace. The key is to think of your workspaces as independent, small projects in your repository whose purpose is to straightforwardly share code to other parts of your repository. This includes dependencies and source code that is required to develop and build that workspace.\n\nIn this way, you'll start thinking of your monorepo in self-contained slices that expose an API to the outside world. This should sound familiar if you're used to writing modular code. In a monorepo, we can encourage ourselves and our teammates to use the workspace boundary as a module boundary.\n\n## Tasks in a workspace should be self-contained\n\nAs we start thinking about packages this way, a great way to check if you are handling your workspaces correctly is to see if the tasks of the workspace run without reaching for code outside the workspace. Any code that is used in the workspace should come from a dependency installed in that workspace.\n\n### Using ESLint as an example\n\nA common example I've seen of breaking this rule (where we shouldn't be) is with ESLint. An incorrect ESLint setup would place a `eslintrc.json` at the root of the project and run a `eslint .` from the root as well.\n\nThis comes with problems:\n\n- We can't parallelize this task. ESLint is going to have to work it's way through each workspace one-by-one.\n- We can't granularly cache this task since there is only one linting script happening at the root of the repository. If we change _any_ code in the repository, we would have to run the entire lint task for the whole repository again.\n- Handling the needs of different workspaces becomes difficult. The lines that you draw between your workspaces are muddied when you do this and you start leaning into [yolorepo](/monorepos/glossary#yolorepo) territory. We should avoid it when you can.\n\nYou'll learn how to [improve your type checking scripts in the TypeScript section](/monorepos/guardrails/typescript) but let's go back to continuing to refine our mental model.\n\n## Thinking in dependency graphs\n\nWhen we install one workspace into another, we've created a relationship between those workspaces from \"producer\" to \"consumer.\" For example, a workspace containing a UI package produces and exposes an API surface to a \"consumer\" web application.\n\n<Img\n  srcLight=\"/images/maestros/basic-dep-graph-light.png\"\n  srcDark=\"/images/maestros/basic-dep-graph-dark.png\"\n  alt=\"An image showing an arrow between two boxes. The first box has the label 'UI package' with an arrow pointing to a 'web application'. The line is labeled with 'pnpm i' to demonstrate that we install the UI package into the web application.\"\n  width={3000}\n  height={2400}\n/>\n\nBut, remember that these are Typescript applications so we do need to have some configuration to handle our TypeScript. We'll create a common TypeScript configuration that we'll install into our workspaces to set those up.\n\n<Img\n  srcLight=\"/images/maestros/dep-graph-with-config-package-light.png\"\n  srcDark=\"/images/maestros/dep-graph-with-config-package-dark.png\"\n  alt=\"The same image as the previous but we've added a box with 'ESLint configuration package.' This package is installed into each application.\"\n  width={3000}\n  height={2400}\n/>\n\nWe've now earned ourselves a mental model where we can think about our monorepo graphically because we created clearly defined boundaries. We can think of our repository with a \"direction\", working from the bottom of our dependency tree (configurations) all the way up to the top (applications).\n\n## If you're learning this for the first time...\n\nThese ideas may sound a little abstract - but that's okay! For the rest of this reference, we will be more hands-on with some code and see how these concepts work in action.\n\nLet's now take a look at setting the scene for your repository in [your repository's root](/monorepos/basics/root).",
    "_meta": {
      "filePath": "lessons/basics/index.mdx",
      "fileName": "index.mdx",
      "directory": "lessons/basics",
      "extension": "mdx",
      "path": "lessons/basics"
    }
  },
  {
    "title": "The root",
    "sidebarOrderPosition": 0,
    "ogDescription": "The root of a monorepo",
    "content": "import { FileTree } from '#/components/FileTree';\nimport { Callout } from '#/components/Callout';\n\nIn the root of your project, there is a minimal set of files that you must have to make sure things work correctly.\n\n<FileTree>\n  <FileTree.File name=\".gitignore\" />\n  <FileTree.File name=\"turbo.json\" />\n  <FileTree.File name=\"package.json\" />\n  <FileTree.File name=\"pnpm-lock.yaml\" />\n  <FileTree.File name=\"pnpm-workspace.yaml\" />\n</FileTree>\n\n### .gitignore\n\nA `.gitignore` file isn't unique to a monorepo but it's still essential to have. There will be many files that we create while we're working locally that don't belong in source control. A minimally effective `.gitignore` may look like:\n\n```js filename=\".gitignore\" note=\"Make sure you add any directories or files you may need for your project.\"\n# dependencies\nnode_modules\n.pnp\n.pnp.js\n\n# testing\ncoverage\n\n# next.js\n.next/\nout/\nbuild\n\n# misc\n.DS_Store\n*.pem\n\n# debug\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n\n# local env files\n.env\n.env.local\n.env.development.local\n.env.test.local\n.env.production.local\n\n# turbo\n.turbo\n```\n\n### turbo.json\n\nThis file is responsible for setting up the tasks that we will run in our monorepo. It will define tasks into \"pipelines,\" ensuring that we create a certain order with our tasks so things run correctly (and fast). A minimal `turbo.json` with a build task for Next.js applications looks like:\n\n```json filename=\"turbo.json\"\n{\n  \"pipeline\": {\n    \"build\": {\n      \"dependsOn\": [\"^build\"],\n      \"outputs\": [\".next/**\", \"!.next/cache/**\"]\n    }\n  }\n}\n```\n\nWe'll talk more about this file when we make it to [monorepo managers](/monorepos/managers) but for right now, all we want to remember is: **This file is responsible for conducting the symphony.**\n\n### package.json\n\nThis is the absolute home of our repository, where it all starts. In our root `package.json`, we'll do a number of important things:\n\n- Install our monorepo manager\n- Create default scripts for easy access\n- Define the package manager for the repository\n\n```json filename=\"package.json\" note=\"We're using pnpm for the sake of demonstration. You can use your favorite.\"\n{\n  \"name\": \"my-repo\",\n  \"private\": true,\n  \"scripts\": {\n    // ...\n  },\n  \"devDependencies\": {\n    \"turbo\": \"latest\"\n  },\n  \"packageManager\": \"pnpm@8.0.0\"\n}\n```\n\n### A lockfile\n\nWe'll also need a lockfile for our package manager. The lockfile is responsible for ensuring that the same dependencies are installed whenever someone uses our monorepo.\n\nIf we don't have a lockfile, it would be possible to install different dependencies across developers and CI machines, leading to unexpected behavior. When we commit our lockfile to source control, we'll know that everyone is going to be using the same dependencies so we'll have a more stable system.\n\n### Workspace definition file\n\n<Callout type=\"warning\">\n  We only need this file when we are using pnpm. npm and Yarn define their\n  workspaces in your root package.json instead. We'll discuss these nuances\n  further in the section on package managers.\n</Callout>\n\nFor pnpm monorepos, we need to create a file to tell pnpm where our workspaces are located. If you're using the usual monorepo structure with `apps` and `packages`, it will look like:\n\n```yml filename=\"pnpm-workspace.yml\"\npackages:\n  - apps/*\n  - packages/*\n```\n\n## Moving out to workspaces\n\nWith the root of the repository handled, we can move out to [creating workspaces](/monorepos/basics/workspaces) to start building the more active parts of our codebase.",
    "_meta": {
      "filePath": "lessons/basics/root.mdx",
      "fileName": "root.mdx",
      "directory": "lessons/basics",
      "extension": "mdx",
      "path": "lessons/basics/root"
    }
  },
  {
    "title": "Workspaces",
    "sidebarOrderPosition": 1,
    "ogDescription": "Building workspaces in a monorepo",
    "content": "Workspaces are the fundamental “slices” of your monorepo. In a monorepo, you will create workspaces that are installable into other workspaces similar to adding a package from the npm registry.\n\n## Conventions\n\nA typical way to set up a product-facing monorepo is to create an `apps` directory and a `packages` directory. Monorepos for libraries are often a little different because they have different needs - but the same workspacing techniques still apply.\n\n### `apps`\n\nIn `apps`, you'll find independently deployable applications that you'll ship to your users. You won't ever install an app into a different workspace; they're at the absolute top of your dependency graph.\n\n### `packages`\n\nThis is where we share code from. We'll install these into our applications and even other packages as needed.\n\n### `tooling`\n\nPersonal opinion incoming: I often like to add a `tooling` directory as well. In `tooling`, I put packages meant for the configuration of the repository rather than source code that will contribute to the code for applications. \"Meta-packages\" might be another way to think of these. Examples include TypeScript, ESLint, Prettier, and Tailwind configurations.\n\n## Defining workspaces\n\nnpm and Yarn create workspaces by defining them in your repo's root `package.json`. Once set up, your package manager will know how to identify `package.json`'s in your code and treat them as workspaces.\n\nTo learn how to set up workspaces for your package manager, check their pages:\n\n- [pnpm](/monorepos/package-managers/pnpm#workspaces)\n- [Yarn](/monorepos/package-managers/yarn#workspaces)\n- [npm](/monorepos/package-managers/npm#workspaces)\n\n## Anatomy of a workspace\n\nThe groundwork for understanding how a workspace can be found in `package.json`, the file that defines many of the characteristics of your workspaces like its name, dependencies, scripts, and exports.\n\n```json filename=\"package.json\" lang=\"json\"\n{\n  \"name\": \"@repo/my-package\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"exports\": {\n    \".\": \"./src/index.ts\"\n  },\n  \"scripts\": {\n    \"format\": \"prettier \\\"**/*.{ts,tsx,md,mdx,json}\\\" --check\",\n    \"lint\": \"eslint .\",\n    \"typecheck\": \"tsc --noEmit\"\n  },\n  \"dependencies\": {\n    // ...\n  },\n  \"devDependencies\": {\n    \"@repo/lint\": \"workspace:*\",\n    \"@repo/prettier\": \"workspace:*\",\n    \"@repo/tsconfig\": \"workspace:*\",\n    \"typescript\": \"5.1.3\"\n  }\n}\n```\n\n- `name`: Field defined in package.json that is used to reference this package in the rest of your monorepo. It's a best practice to namespace your workspaces so that you know you won't have collisions with external dependencies.\n\n- `dependencies`: Packages that you install into your workspace. Dependencies bring code from outside your workspace and can be external or internal to your monorepo.\n\n- `scripts`: The runnable tasks that your workspace executes. Think of them like \"verbs\" for your workspace. Things you want to do like build, lint, test, etc.\n\n- `exports`: The entrypoints of your workspace. You don't need to define these for applications. In packages, these are what are exposed by the workspace for other workspaces for use. We'll discuss techniques for creating these entrypoints with more depth in [the packaging section](/monorepos/packaging).\n\n- Source code: The code that you write that we will share or deploy, depending on if your workspace is a package or an application.",
    "_meta": {
      "filePath": "lessons/basics/workspaces.mdx",
      "fileName": "workspaces.mdx",
      "directory": "lessons/basics",
      "extension": "mdx",
      "path": "lessons/basics/workspaces"
    }
  },
  {
    "title": "Cache means fast",
    "sidebarOrderPosition": 0,
    "ogDescription": "Using caching in your monorepo",
    "content": "At it's core, Turborepo makes things fast by leveraging caching for monorepos. While caching isn't a new concept in development, bringing this pattern to JavaScript and TypeScript monorepos means we can drastically speed up builds, tests, lints, type checks, and other tasks that happen in your monorepo.\n\n## How it works\n\nThe first time that you run a task, Turborepo won't know the end result of the work you've asked for. The task(s) will run from start to finish, taking their full time to execute.\n\n![Caching Diagram](/images/maestros/ci-uncached.png)\n\nHowever, if we run our task again using the same inputs, we will hit cache and all of our tasks will be complete in milliseconds.\n\n![Caching Diagram](/images/maestros/ci-cached.png)\n\nWhile these images come from a small repository with already quick tasks, the time you get back adds up quickly. You can see how much time the [Vercel Remote Cache]() has saved on [the Turborepo docs](https://turbo.build/repo/docs). At the time of this writing, over **900 days of compute time had been saved**!\n\n## Using a Remote Cache\n\nWhile this concept is powerful for a single developer on their local machine, Remote Caching is where gigantic speedups can be found.\n\nThrough Remote Caching, your local machine and every CI machine can be connected, creating a multiplayer, distributed cache that allows everyone to use caches for tasks that have been ran before. If you run `turbo lint` on your local machine, your CI will instantly hit a cache when it runs `turbo lint`.\n\n### Setting up the Remote Cache\n\nWhile you can use [Custom Remote Caches](https://turbo.build/repo/docs/core-concepts/remote-caching#custom-remote-caches) with Turborepo, it's easiest to demonstrate how the Remote Cache works with Vercel since we won't have to set up any infrastructure for a quick demo.\n\n[Check out the Deploying to Vercel](/monorepos/ci-cd/vercel) and [GitHub Actions](/monorepos/ci-cd/github-actions) pages to learn more.",
    "_meta": {
      "filePath": "lessons/ci-cd/caching.mdx",
      "fileName": "caching.mdx",
      "directory": "lessons/ci-cd",
      "extension": "mdx",
      "path": "lessons/ci-cd/caching"
    }
  },
  {
    "title": "Feature flags",
    "sidebarOrderPosition": 2,
    "ogDescription": "Using feature flags in a monorepo",
    "content": "// import { UnderConstruction } from '../../UnderConstruction';\n\n{/* <UnderConstruction /> */}",
    "_meta": {
      "filePath": "lessons/ci-cd/feature-flags.mdx",
      "fileName": "feature-flags.mdx",
      "directory": "lessons/ci-cd",
      "extension": "mdx",
      "path": "lessons/ci-cd/feature-flags"
    }
  },
  {
    "title": "GitHub Actions",
    "sidebarOrderPosition": 1,
    "ogDescription": "Using GitHub Actions in a monorepo",
    "content": "Creating checks in GitHub Actions ensures that our repository maintains its health through constant development. All of the developers in the repository will need to follow the guardrails that we have codified into our checks, making our entire monorepo predictable, safe, and a joy to work in at any scale.\n\nRather than rewrite [the excellent instructions from the Turborepo documentation](https://turbo.build/repo/docs/ci/github-actions), we encourage you to [visit their guide](https://turbo.build/repo/docs/ci/github-actions) to learn how to set up `turbo` to run checks in your repository.\n\nBelow, we will talk about a few techniques of GitHub Actions that we use in [the Maestros repository](https://github.com/anthonyshew/maestros) that you can leverage.\n\n## Running a GitHub action for trunk-based deployments\n\nAs mentioned on [our CI/CD introduction page](/monorepos/ci-cd), our goal is to always be merging our pull requests to the main branch. To make sure the checks that we've written run when we put up a pull request under these conditions, we need to write this rule into the top of our GitHub Action:\n\n```yml filename=\".github/workflows.quality.yml\"\nname: Quality\n\non:\n  push:\n    branches: ['main']\n  pull_request:\n    types: [opened, synchronize]\n\njobs:\n```\n\nThe `on` block informs GitHub to run the Action whenever a `pull_request` is `opened` or updated (`synchronize`) to the `branches` in the provided array (in our case, `main`). Our developers will now be informed about any code that doesn't follow the conventions established in our codebase.\n\n## Creating a uniform installation action\n\nThe jobs in the GitHub Actions of a monorepo often need to go through similar setup steps. We can create a common setup step to reduce boilerplate and keep things more simple. Let's learn about this by taking a look at [the setup steps for the Actions in this repo](https://github.com/anthonyshew/maestros/blob/main/tooling/github-actions/setup/action.yml):\n\n```yml filename=\"./tooling/github-actions/setup/action.yml\"\nname: 'Setup and install'\ndescription: 'Common setup steps for Actions'\n\nruns:\n  using: composite\n  steps:\n    - uses: actions/setup-node@v3\n      with:\n        node-version: 18\n\n    - uses: actions/checkout@v3\n\n    - shell: bash\n      run: npm i -g pnpm turbo\n\n    - shell: bash\n      run: pnpm install\n```\n\nA few key details to keep in mind when reading this file are:\n\n- `using: composite`: Makes it possible for this file to be used in jobs in another GitHub actions yml file\n- `npm i -g pnpm turbo`: GitHub Actions runners do not have pnpm or turbo available by default so we need to install them with npm first.\n- `pnpm install`: Install all of our packages for our repo now that they are available.\n\n## Canceling stale jobs\n\nIf you're pushing updates to your branch faster than your checks are completing, you'll end up kicking off many Actions than you need. It would be great if Actions that are running on stale code could be cancelled...\n\nWell, we can do exactly that!\n\n```yml filename=\"./.github/workflows/quality.yml\"\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}\n```\n\nThis block of code tells a GitHub Action to cancel any workflows that are:\n\n1. Named the same as the current workflow\n2. Have the same branch name as the current workflow\n\nWe will not only ever have one active Action that is checking, for example, our formatting, no matter how many times we push new code to your pull request.",
    "_meta": {
      "filePath": "lessons/ci-cd/github-actions.mdx",
      "fileName": "github-actions.mdx",
      "directory": "lessons/ci-cd",
      "extension": "mdx",
      "path": "lessons/ci-cd/github-actions"
    }
  },
  {
    "title": "CI/CD and Deployment",
    "sidebarOrderPosition": 6,
    "ogDescription": "Handling CI/CD in a monorepo",
    "content": "Developing an app is great fun but, at the end of it all, shipping is what matters.\n\nContinuous deployment and continuous integration can be done in a lot of different ways. In Maestros, we'll discuss simple, powerful patterns to get web applications online to get you started. As your skills grow into more bespoke system, you'll have a good foundation to work from.\n\nOn this page, we'll discuss the high-level process of getting an application out to production in a fast, maintainable, and predictable way.\n\n## General process\n\nThe conventional process for getting code out to production in a modern CI/CD process follows this general pattern:\n\n1. Developer writes code.\n2. Developer commits code to git and creates a pull request to the main branch of the codebase.\n3. Automated checks are ran against the newly committed code. Additionally, one or more reviewers are asked to read through the code.\n4. Once code passes all automated checks and has been reviewed, it is merged and deployed to production.\n\n## Common objections\n\nIn a monorepo, specifically, issues can arise in this process if you aren't using good tooling. Let's talk about these potential problems below and discuss how the techniques in Maestros solve them.\n\n### Release management\n\nA common misconception is that constantly putting new code on the mainline means that you will be constantly releasing new code to the hot paths of your application. If you're working on a new feature, you want to release it when it is complete instead of the first time that you write code for it.\n\nTo account for this, we use [feature flags](/monorepos/ci-cd/feature-flags). In a modern CI/CD process, you (nearly) always want to be merging into main through [trunk-based development](https://www.atlassian.com/continuous-delivery/continuous-integration/trunk-based-development). This allows you to:\n\n- Develop in small batches\n- Learn about merge conflicts faster (and reduce them in general)\n- Test code sooner\n- Ship faster\n\nWe'll discuss what this looks like more on the [Feature Flags page](/monorepos/ci-cd/feature-flags).\n\n### Slower feedback loops\n\nA common concern with monorepos is that there's simply more code in the codebase to run checks against. That means that checks will run slower since there is more work to do for more code.\n\nThis is a very valid concern. Our developers deserve tight feedback loops. Waiting an hour for checks to run against millions of lines of code should be considered unacceptable.\n\nThe good news is that we can easily resolve this concern with Turborepo. [With caching](/monorepos/ci-cd/caching), we can ensure that we never do the same work twice.\n\n## Tools for the job\n\nAs mentioned before, we're going to administer a straightforward pipeline using [GitHub Actions](/monorepos/ci-cd/github-actions) and [deploying to Vercel](/monorepos/ci-cd/deployment). There are absolutely other actions providers, platforms, and tooling that you can use if you prefer others (and we hope to add more in the future!).",
    "_meta": {
      "filePath": "lessons/ci-cd/index.mdx",
      "fileName": "index.mdx",
      "directory": "lessons/ci-cd",
      "extension": "mdx",
      "path": "lessons/ci-cd"
    }
  },
  {
    "title": "Deploy to Vercel",
    "sidebarOrderPosition": 3,
    "ogDescription": "Deploy to Vercel from a monorepo",
    "content": "Vercel features built-in CI/CD that can build Turborepo applications with near-zero configuration. To show you how this works, we can deploy two applications to Vercel in under 5 minutes without ever leaving the command line!\n\n## Prerequisites\n\n- [Vercel CLI](https://vercel.com/docs/cli)\n- A Vercel account (If you don't have one yet, you'll be prompted to create one when you run the CLI for the first time.)\n- [GitHub CLI](https://cli.github.com/) (Recommended if you don't want to leave your terminal.)\n- A GitHub account\n\n## Create a new Turborepo\n\nFor demo purposes, let's use the Turborepo starter.\n\n```bash filename=\"Terminal\"\nnpx create-turbo@latest\ncd my-turborepo # or whatever name you used\n```\n\n## Create a repository on GitHub\n\nIn your new repository, make sure you have a remote to commit your code to.\n\n```bash filename=\"Terminal\"\ngh repo create --public --source=. --remote=origin\n```\n\n## Link your repository to Vercel\n\nNow that your local repository has a remote on GitHub, you can create projects on Vercel that are connected to your remote using [Vercel CLI](https://vercel.com/docs/cli).\n\n```bash filename=\"Terminal\"\nvercel link --repo\n```\n\nThis command will create a new file at the root of your repository at `.vercel/repo.json` where you'll find a mapping of your applications to Vercel projects.\n\n## Ship!\n\nYou're ready to go! Time to ship your applications.\n\nTo ship your `docs` app:\n\n```bash filename=\"Terminal\"\ncd apps/docs\nvercel\n```\n\nTo ship your `web` app:\n\n```bash filename=\"Terminal\"\ncd apps/web\nvercel\n```\n\nYou've now shipped two preview deployments from one monorepo. You could also choose to run `vercel --prod` to ship to production.\n\nVercel will use your [Vercel Remote Cache](https://vercel.com/docs/monorepos/remote-caching) with zero-configuration. Through [workspace-level caching](/monorepos/ci-cd-caching), you'll always be shipping as fast as possible.\n\n## Iterate!\n\nTo get your local machine hooked up to your [Vercel Remote Cache](https://vercel.com/docs/monorepos/remote-caching#vercel-remote-cache), run two quick commands:\n\n```bash filename=\"Terminal\"\nnpx turbo login\nnpx turbo link\n```\n\nYou'll now be sharing tasks across machines, never duplicating work across your local and CI machines.\n\nAs you continue building, you can push code to GitHub on branches and pull requests to create new preview deployments and ship code to production. You can also create one-off preview deployments using `vercel` in your terminal to ship your current changes to a Preview Deploy whenever you'd like.",
    "_meta": {
      "filePath": "lessons/ci-cd/vercel.mdx",
      "fileName": "vercel.mdx",
      "directory": "lessons/ci-cd",
      "extension": "mdx",
      "path": "lessons/ci-cd/vercel"
    }
  },
  {
    "title": "ESLint",
    "sidebarOrderPosition": 0,
    "ogDescription": "Setting up ESLint in a monorepo.",
    "content": "import { FileTree } from '#/components/FileTree';\nimport { Callout } from '#/components/Callout';\n\nESLint is the most common linter used in the JavaScript world today. Setting it up in a monorepo can be difficult and piecing together the various configurations can be frustrating.\n\nBut we're maestros! We can do this. Let's take a look at how to happily set up ESLint for monorepo success.\n\n## Setting up ESLint\n\nAs we head into getting ESLint set up, let's remember our requirements for conducting a monorepo symphony:\n\n- We want our workspaces to be as self-contained as possible.\n- We want our workspace tasks to happen _within_ our workspaces.\n- We want to encourage standardization across the entirety of our monorepo while still allowing for flexibility in workspaces when needed.\n- One-way configuration flow. When you need to understand what you're configuring for a package, you always have a singular \"place\" to start from and then you can work outwards.\n\n### Creating presets\n\nTo create some presets for our workspaces, we'll set up a workspace with our configurations in `tooling/eslint-config`.\n\n<FileTree>\n  <FileTree.Folder name=\"tooling\" open>\n    <FileTree.Folder name=\"eslint-config\" open>\n      <FileTree.File name=\".eslintrc.js\" />\n      <FileTree.File name=\"next.js\" />\n      <FileTree.File name=\"node.js\" />\n      <FileTree.File name=\"svelte.js\" />\n      <FileTree.File name=\"package.json\" />\n    </FileTree.Folder>\n  </FileTree.Folder>\n</FileTree>\n\nOur `package.json` will be relatively simple, installing `eslint` and including the files for our presets.\n\n```json filename=\"tooling/eslint-config/package.json\" lang=\"json\"\n{\n  // focus(1:1)\n  \"name\": \"@repo/lint\",\n  \"version\": \"0.0.0\",\n  // focus(1:1)\n  \"files\": [\"node.js\", \"next.js\", \"svelte.js\"],\n  \"scripts\": {\n    \"lint\": \"eslint .\"\n  },\n  // focus(1:3)\n  \"dependencies\": {\n    \"@next/eslint-plugin-next\": \"latest\", // We'll need this for the Next.js config in a moment.\n    \"eslint\": \"^8.40.0\"\n  }\n}\n```\n\n<Callout type=\"info\">\n  The `lint` script in `package.json` is for linting the `eslint-config`\n  workspace itself. It is not the script that runs in your other workspaces.\n</Callout>\n\nIt's typical that not all of our workspaces will use the exact same linting configuration. As an example, default exports tend to be inadvisable for JavaScript modules but some frameworks require default exports to work properly (e.g. A Next.js `page.js` file needs a default export). We can account for this by creating multiple base configurations.\n\nWe'll create a `node.js` file for simple Node apps:\n\n```js filename=\"tooling/eslint-config/node.js\" lang=\"js\"\nmodule.exports = {\n  ignorePatterns: ['node_modules/', '**/.eslintrc.js', 'dist/'],\n  root: true,\n};\n```\n\nAnd a `next.js` file to use in our Next.js apps:\n\n```js filename=\"tooling/eslint-config/next.js\" lang=\"js\"\nconst { rules } = require('./utils/rules');\n\nmodule.exports = {\n  extends: ['next'],\n  ignorePatterns: ['**/.next/**', '**/.eslintrc.js'],\n  overrides: [\n    {\n      files: [\n        'pages/**',\n        'src/pages/**',\n        'next.config.js',\n        'app/**/{head,layout,loading,page,error,not-found}.tsx',\n        'contentlayer.config.ts',\n      ],\n      rules: {\n        'import/no-default-export': 'off',\n      },\n    },\n  ],\n  root: true,\n};\n```\n\nUsing your newfound knowledge, you can also add any extra configurations that you see fit.\n\n### Adding presets to workspaces\n\nNow, we'll want to use these presets out in a workspace. To do so, we'll need to do two things:\n\n1. Create a `.eslintrc.js` file in the workspace.\n\n```js filename=\"packages/logger/.eslintrc.js\" lang=\"js\"\n/** @type {import(\"eslint\").Linter.Config} */\nmodule.exports = {\n  extends: [require.resolve('@repo/lint/node')], // Installed in next step\n  root: true, // Very important!\n};\n```\n\nNote the `root: true` property! This tells ESLint that it doesn't need to look outside of your workspace for any more configuration. By default, ESLint will look upwards in your project for more configuration.\n\n`root: true` prevents this. All of the config to be used within the workspace is now in the `extends` key and the workspace file itself.\n\n2. Install our `@repo/lint` package to the workspace and create a lint script.\n\n```json filename=\"packages/logger/package.json\" lang=\"json\"\n{\n  \"name\": \"@repo/logger\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    // focus(1:2)\n    \"lint\": \"eslint . --cache --cache-location 'node_modules/.cache/.eslintcache' --max-warnings 0\",\n    \"lint:fix\": \"eslint . --fix --cache --cache-location 'node_modules/.cache/.eslintcache' --max-warnings 0\"\n  },\n  \"devDependencies\": {\n    // focus(1:2)\n    \"@repo/lint\": \"workspace:*\",\n    \"eslint\": \"^8.42.0\"\n  }\n}\n```\n\nWe're including some flags on these commands. You can learn more about them in [the ESLint CLI documentation](https://eslint.org/docs/latest/use/command-line-interface) but, to make a long story short:\n\n- `--cache`: Used cached assets to make ESLint run much faster.\n- `--cache-location`: Tell ESLint where to look for the cache file.\n- `--max-warnings`: How many warnings are you willing to accept and still let your CI pass? If you can, make this 0.\n- `--fix`: Fix any auto-fixable errors that ESLint may encounter.\n\n### Overriding rules in a workspace\n\nTo build off of our presets for any specific needs in a particular workspace, you can leverage the `overrides` property of ESLint. It may look something like this:\n\n```js filename=\"packages/ui/.eslintrc.js\" lang=\"js\"\nmodule.exports = {\n  extends: [require.resolve(\"@repo/lint/node\")]\n  root: true,\n  // focus(1:3)\n  overrides: [\n    // Your overrides here.\n  ],\n};\n```\n\n## Linting the root\n\nYou can also ensure that you're linting any JavaScript/TypeScript files that aren't in your workspaces.\n\n### Add a root .eslintrc.js\n\nWe'll first need a configuration file for our ESLint to use.\n\n```js filename=\"./.eslintrc.js\" lang=\"js\"\nmodule.exports = {\n  extends: [require.resolve(\"@repo/lint/node\")]\n  root: true,\n};\n```\n\n### Create a linting task\n\nWe'll now create a root linting task that looks like the ones from our workspaces - but with one key addition.\n\n```json filename=\"package.json\" lang=\"json\"\n{\n  \"name\": \"my-monorepo\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    // focus(1:2)\n    \"lint\": \"eslint . \\\"!apps/** !packages/** !tooling/**\\\" --cache --cache-location 'node_modules/.cache/.eslintcache' --max-warnings 0\",\n    \"lint:fix\": \"eslint . \\\"!apps/** !packages/** !tooling/**\\\" --fix --cache --cache-location 'node_modules/.cache/.eslintcache' --max-warnings 0\"\n  },\n  \"devDependencies\": {\n    // focus(1:2)\n    \"@repo/lint\": \"workspace:*\",\n    \"eslint\": \"^8.42.0\"\n  }\n}\n```\n\nThe `\\\"!apps/** !packages/** !tooling/**\\\"` phrase ensures that our root ESLint task doesn't try to lint our workspaces - because our workspaces are responsible for themselves!\n\n## Write a pipeline\n\nOnce we've created our linting scripts in any workspaces that we want to lint, it's time to build up our Turborepo pipelines.\n\n```json filename=\"turbo.json\" lang=\"json\"\n{\n  \"pipeline\": {\n    \"topo\": {\n      \"dependsOn\": [\"^topo\"]\n    },\n    \"//#lint\": {\n      \"outputs\": [\"node_modules/.cache/.eslintcache\"]\n    },\n    \"lint\": {\n      \"dependsOn\": [\"^topo\"],\n      \"outputs\": [\"node_modules/.cache/.eslintcache\"]\n    },\n    \"//#lint:fix\": {\n      \"dependsOn\": [\"^topo\"],\n      \"outputs\": [\"node_modules/.cache/.eslintcache\"],\n      \"cache\": false\n    },\n    \"lint:fix\": {\n      \"dependsOn\": [\"^topo\"],\n      \"outputs\": [\"node_modules/.cache/.eslintcache\"],\n      \"cache\": false\n    }\n  }\n}\n```\n\nWe're using a few Turborepo techniques in the pipelines above to keep things speedy.\n\n- **`//#` for root tasks**: Tasks that need to be ran for the root of your repository must begin with `//#`.\n- **Recursively depending on `topo`**: This is [a little trick from the Turborepo documentation](https://turbo.build/repo/docs/core-concepts/monorepos/task-dependencies#dependencies-outside-of-a-task). In short, this `dependsOn` pattern flattens your task graph so that everything runs in parallel while still respecting changes in workspace dependencies. (If that sounds confusing, don't worry about it for now; just trust that it works. We'll be writing up a doc for this but, for the time being, let it be magic.) ✨\n- **Using ESLint caching**: We're about to create an `.eslintcache` file in our workspaces in the next step. In the event that our task misses cache, we will still have the `.eslintcache` to use to speed up our task. Caching this file as a Turborepo `output` ensures that we have the `.eslintcache` shared across our machines as often as possible so we can use it in as many places as we can.\n\n## Run our lint tasks\n\nWith all of that ready to go, we're now ready to run our tasks!\n\nIn the root of our monorepo, we will create these scripts:\n\n```json filename=\"package.json\" lang=\"json\" note=\"--continue runs the rest of your tasks even if one fails.\"\n{\n  \"scripts\": {\n    \"lint\": \"turbo lint --continue\",\n    \"lint:fix\": \"turbo lint:fix --continue\"\n  }\n}\n```\n\nRun `pnpm lint`! On the first run, the command will create caches in each workspace both at the ESLint and Turborepo layers.\n\n- Running `pnpm lint` (without changing any code) will give you a `>>> FULL TURBO`. Awesome!\n- Changing some code in one workspace will hit cache for all your workspaces except that specific one. That workspace will use the ESLint cache file at `node_modules/.cache/.eslintcache` in each workspace to lint as fast as possible.\n- You can also run your `pnpm lint:fix` command to see if ESLint can find any auto-fixable problems.\n\nWith this all in place, you can run your linting tasks with incredible speed.",
    "_meta": {
      "filePath": "lessons/guardrails/eslint.mdx",
      "fileName": "eslint.mdx",
      "directory": "lessons/guardrails",
      "extension": "mdx",
      "path": "lessons/guardrails/eslint"
    }
  },
  {
    "title": "Building guardrails",
    "sidebarOrderPosition": 4,
    "ogDescription": "Encoding uniformity and safety in your monorepo",
    "content": "import { Callout } from '#/components/Callout';\n\nAn important part of creating a great monorepo is ensuring that you build safeguards for your developers. Formatters, linters, and type checkers help all developers in a repository work as quickly as possible by paving happy paths throughout your repository.\n\nWhen we build guardrails correctly, we'll have rules that allow us to do our best work **without blocking progress**. Our goal is to improve velocity, not build annoying roadblocks.\n\nWe'll use a combination of tools to make this happen, integrating these tools with our local environment and CI pipelines.\n\n<Callout type=\"goodToKnow\">\n  Yes, there are other tools out there for these purposes. The three shown below\n  are by far the most common. In the future, we'd love to explore other\n  formatting and linting tooling.\n</Callout>\n\n## ESLint for linting\n\n**Note that a linter is for verifying and correcting logic, names, and potential bugs in your code.** By statically analyzing certain characteristics of your code, a linter should be able to keep you working smoothly.\n\nWe'll use [ESLint](https://eslint.org/) for this since its the most common tool for linting in the JavaScript world.\n\n[Learn how to use ESLint in a monorepo.](/monorepos/guardrails/eslint)\n\n## Prettier for formatting\n\n**Note that a formatter is specifically for formatting, not code quality.** It will handle simple things like whitespace, semi-colons, and dangling commas. It should run quickly and not be concerned with code logic or naming conventions.\n\nThe most common formatter in the JavaScript ecosystem is [Prettier](https://prettier.io/) so we'll use that.\n\n[Learn how to use Prettier in a monorepo.](/monorepos/guardrails/prettier)\n\n## TypeScript for type checking\n\n**Note that a type checker is for ensuring that data used in your code is of a specific \"type\". A type checker is not responsible for whitespace, stylistic, or \"taste\" decisions.**\n\nAnthony's personal opinion incoming: TypeScript is a must-have for any JavaScript-based project today. You'll see pure JavaScript sprinkled throughout Monorepo Maestros but we will **always overwhelmingly** favor TypeScript for our monorepos.\n\n[Learn how to use TypeScript in a monorepo.](/monorepos/guardrails/typescript)",
    "_meta": {
      "filePath": "lessons/guardrails/index.mdx",
      "fileName": "index.mdx",
      "directory": "lessons/guardrails",
      "extension": "mdx",
      "path": "lessons/guardrails"
    }
  },
  {
    "title": "Prettier",
    "sidebarOrderPosition": 1,
    "ogDescription": "Setting up Prettier in your monorepo.",
    "content": "import { FileTree } from '#/components/FileTree';\n\n[Prettier](https://prettier.io/) is a great formatter for quickly taking care of simple, syntax consistency in your codebase. You can automatically standardize your entire codebase to have the same stylistic qualities and never worry about it again.\n\n## Setting up Prettier\n\nPrettier has one simple job: standardize syntax. That simplicity can be reflected in the way that we set up Prettier since there isn't a need for overriding configurations in workspaces.\n\nWe will still be able to format our workspaces as their own separate tasks to take advantage of caching but we will only have one file in our repository for establishing style.\n\n### Add Prettier to your repo\n\nIn your root `package.json`, you'll need to do two things:\n\n1. Install `prettier` (and `prettier-plugin-packagejson` if you'd like to format those).\n2. Add your formatting scripts.\n\n```json filename='./package.json' note=\"Prettier ^3.0.0 currently breaks the VSCode plugin for monorepos. We're sticking with ^2.8.0 for now.\"\n{\n  \"name\": \"my-project\",\n  \"version\": \"0.1.0\",\n  \"scripts\": {\n    \"format\": \"prettier . \\\"!apps/** !packages/** !tooling/**\\\" --check --cache --cache-location='node_modules/.cache/.prettiercache'\",\n    \"format:fix\": \"prettier . \\\"!apps/** !packages/** !tooling/**\\\" --write --cache --cache-location='node_modules/.cache/.prettiercache' --log-level=warn\"\n  },\n  \"devDependencies\": {\n    \"prettier\": \"^3.0.3\",\n    \"prettier-plugin-packagejson\": \"^2.4.3\",\n    \"turbo\": \"^1.10.13\"\n  }\n}\n```\n\nWe're including some flags on these commands so our tasks go as fast as possible. You can learn more about them in [the Prettier CLI documentation](https://prettier.io/docs/en/cli.html) but, to make a long story short:\n\n- **Ignore file globs**: We don't want our root Prettier task to format our workspaces (because they will format themselves).\n- `--cache`: Use cached assets to make Prettier runs faster.\n- `--cache-location`: Assign a specific location for the Prettier cache file.\n- `--loglevel`: Prevent writing every file that Prettier sees to the console.\n\n### Create a Prettier configuration file\n\nIn the root of your project, we'll write our rules for the repository:\n\n```js filename='./.prettierrc.js'\n// Purely for demonstration! Adjust to your liking.\n/** @type {import(\"prettier\").Options} */\nconst config = {\n  tabWidth: 2,\n  semi: false,\n  singleQuote: true,\n};\n\nexport default config;\n```\n\nBoth our root and workspace Prettier scripts will end up using this configuration.\n\n## Add to your workspaces\n\nLet's get our workspaces formatted by adding scripts for these tasks. These are the same ones from the root.\n\n```json filename=\"packages/ui/package.json\"\n{\n  \"name\": \"@repo/ui\",\n  \"version\": \"0.0.0\",\n  // focus(1:6)\n  \"scripts\": {\n    \"format\": \"prettier . --check --cache --cache-location='node_modules/.cache/.prettiercache'\",\n    \"format:fix\": \"prettier . --write --cache --cache-location='node_modules/.cache/.prettiercache' --log-level=warn\"\n  }\n}\n```\n\n### Ignoring code in workspace tasks\n\nPrettier does not look above it's execution context for ignore files. This means that you'll need to create a `.prettierignore` file for each of your workspaces.\n\nYou will always want to ignore formatting for the output directory of your builds. For instance, in a workspace for a Next.js app, you'll want to add an ignore file like this one:\n\n```js filename=\"apps/web/.prettierignore\"\n.env*\n.next\n```\n\n## Write pipelines\n\nOnce we've created our formatting scripts in any workspaces that we want to format, it's time to build up our Turborepo pipelines.\n\n```json filename=\"turbo.json\" lang=\"json\"\n{\n  \"pipeline\": {\n    \"topo\": {\n      \"dependsOn\": [\"^topo\"]\n    },\n    \"//#format\": {\n      \"outputs\": [\"node_modules/.cache/.prettiercache\"]\n    },\n    \"format\": {\n      \"dependsOn\": [\"^topo\"],\n      \"outputs\": [\"node_modules/.cache/.prettiercache\"]\n    },\n    \"//#format:fix\": {\n      \"outputs\": [\"node_modules/.cache/.prettiercache\"],\n      \"cache\": false\n    },\n    \"format:fix\": {\n      \"dependsOn\": [\"^topo\"],\n      \"outputs\": [\"node_modules/.cache/.prettiercache\"],\n      \"cache\": false\n    }\n  }\n}\n```\n\n- **`//#` for root tasks**: Tasks that need to be ran for the root of your repository must begin with `//#`.\n- **Recursively depending on `topo`**: This is [a little trick from the Turborepo documentation](https://turbo.build/repo/docs/core-concepts/monorepos/task-dependencies#dependencies-outside-of-a-task). In short, this `dependsOn` pattern flattens your task graph so that everything runs in parallel while still respecting changes in workspace dependencies. (If that sounds confusing, don't worry about it for now; just trust that it works. We'll be writing up a doc for this but, for the time being, let it be magic.) ✨\n- **Using Prettier caching**: We're about to create a `.prettiercache` file in our workspaces in the next step. In the event that our task misses cache, we will still have the `.prettiercache` to use to speed up our task. Caching this file as a Turborepo `output` ensures that we have the `.prettiercache` shared across our machines as often as possible so we can use it in as many places as we can.\n\n## Run your format tasks\n\nWith all of that ready to go, we're now ready to run our tasks!\n\nIn the root of our monorepo, we will create these scripts:\n\n```json filename=\"package.json\" note=\"--continue runs the rest of your tasks even if one fails.\"\n{\n  \"scripts\": {\n    \"format\": \"turbo format --continue\",\n    \"format:fix\": \"turbo format:fix --continue\"\n  }\n}\n```\n\nRun `pnpm format`! On the first run, the command will create caches in each workspace both at the Prettier and Turborepo layers.\n\n- Running `pnpm format` (without changing any code) will give you a `>>> FULL TURBO`. Awesome!\n- Changing some code in one workspace will hit cache for all your workspaces except that specific one. That workspace will use the Prettier cache file at `node_modules/.cache/.prettiercache` in each workspace to format as fast as possible.\n- You now run your `pnpm format:fix` command to see if Prettier can find any auto-fixable problems.\n\nWith this all in place, you can run your linting tasks with incredible speed.",
    "_meta": {
      "filePath": "lessons/guardrails/prettier.mdx",
      "fileName": "prettier.mdx",
      "directory": "lessons/guardrails",
      "extension": "mdx",
      "path": "lessons/guardrails/prettier"
    }
  },
  {
    "title": "typescript-eslint",
    "sidebarOrderPosition": 3,
    "ogDescription": "Setting up typescript-eslint in your monorepo",
    "content": "[typescript-eslint](https://typescript-eslint.io) is an important addition to a monorepo, bringing the linting of [ESLint](/monorepos/guardrails/eslint) to your TypeScript code. Without typescript-eslint enabled in your repository, ESLint won't be able to properly understand TypeScript and you'll be missing important checks for your codebase health.\n\nOnce properly installed, typescript-eslint will enable new superpowers for your linter, finding bugs, enforcing standards, and recommending a common style for everyone in the codebase.\n\n## Using typescript-eslint\n\nThe official typescript-eslint documentation has [an excellent breakdown on how to use typescript-eslint in a monorepo](https://typescript-eslint.io/linting/typed-linting/monorepos/#one-tsconfigjson-per-package-and-an-optional-one-in-the-root). Rather than rehash their already excellent docs here in Maestros, we encourage you to hop over there to learn the fundamentals. Below, we'll show an example of combining that documentation with the rest of the \"happy path\" here in Maestros.\n\n## Enabling typescript-eslint in our monorepo\n\nOur first step is to install the typescript-eslint packages that we will need into our monorepo. We'll install these dependencies into our `@repo/lint` package.\n\n```json filename=\"tooling/eslint-config\" note=\"You will likely want to set a specific version rather than latest.\"\n{\n  \"name\": \"@repo/lint\",\n  \"dependencies\": {\n    // Replace latest with current version\n    \"@typescript-eslint/eslint-plugin\": \"latest\",\n    \"@typescript-eslint/parser\": \"latest\"\n  }\n}\n```\n\nThe plugin and parser will now be available in our workspaces' linting commands. To enable it, we'll add a few lines to any workspace where we want the plugin enabled.\n\n```js filename=\"packages/ui/.eslintrc.js\"\n/** @type {import(\"eslint\").Linter.Config} */\nmodule.exports = {\n  root: true,\n  extends: [require.resolve('@repo/lint/next.js')],\n  // focus(1:5)\n  parserOptions: {\n    project: true,\n  },\n  plugins: ['@typescript-eslint'],\n};\n```\n\n## Add new linting rules\n\nLast, we'll add the plugin so typescript-eslint can recommend some best practices throughout our codebase. For any of your root configurations that you'd like typescript-eslint to help you with add these to your extends key:\n\n```json filename=\"tooling/eslint-config/node.js\" lang=\"js\"\nextends: ['eslint:recommended', 'plugin:@typescript-eslint/recommended-type-checked']\n```\n\nYou'll now get the recommended lint checks from the typescript-eslint team and avoid some key bugs that could be lurking in your codebase.",
    "_meta": {
      "filePath": "lessons/guardrails/tseslint.mdx",
      "fileName": "tseslint.mdx",
      "directory": "lessons/guardrails",
      "extension": "mdx",
      "path": "lessons/guardrails/tseslint"
    }
  },
  {
    "title": "TypeScript",
    "sidebarOrderPosition": 2,
    "ogDescription": "Setting up TypeScript in your monorepo.",
    "content": "import { Callout } from '#/components/Callout';\n\nHandling TypeScript in a monorepo can be daunting at first. If you set it up wrong, you can end up frustrated with errors that don't make sense and slow type checking scripts.\n\nBut, once you've learned to hold the TypeScript violin just right, the type checking in your repo will be fast and you can iterate safely.\n\nLet's build a simple TypeScript package to find out how this works.\n\n## Create a workspace for a common `tsconfig.json`\n\nFirst, we'll build a TSConfig that will be the base for all the TypeScript code in our repository. We'll always extend off of this base to reduce duplication and know we're working with the right set of defaults every time.\n\nCreate a workspace in your `tooling` directory (or `packages`, whatever you prefer). We'll add a `package.json` that exports a `base.json` file:\n\n```json filename=\"tooling/tsconfig/package.json\" lang=\"json\"\n{\n  // focus(1:1)\n  \"name\": \"@repo/tsconfig\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  // focus(1:1)\n  \"files\": [\"base.json\"]\n}\n```\n\nNote that we don't need to install TypeScript (or anything else!) in this package's dependencies. All we need is a `base.json` TSConfig like this one:\n\n```json filename=\"tooling/tsconfig/base.json\" lang=\"json\"\n{\n  \"$schema\": \"https://json.schemastore.org/tsconfig\", // For in-editor Intellisense\n  \"display\": \"Default\",\n  \"compilerOptions\": {\n    // focus(1:3)\n    \"incremental\": true, // Must have for next steps!\n    \"skipLibCheck\": true, // Highly recommended!\n    \"strict\": true, // Highly recommended!\n    \"composite\": false,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"esModuleInterop\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"inlineSources\": false,\n    \"isolatedModules\": true,\n    \"moduleResolution\": \"Node16\",\n    \"noImplicitAny\": true,\n    \"noUnusedLocals\": false,\n    \"noUnusedParameters\": false,\n    \"preserveWatchOutput\": true\n  },\n  \"exclude\": [\"node_modules\"]\n}\n```\n\nThe TSConfig above has the usual defaults for most projects so feel free to copy-paste. It contains many optional properties that you can tailor it to your liking but, at the very least, make sure you keep:\n\n- `\"strict\": true` so the compiler finds as many mistakes as possible\n- `\"skipLibCheck\": true` so only the source code in your workspace is checked by the task\n- `\"incremental\": true` for faster type checking (which we will discuss in a moment)\n\n## Make the TypeScript compiler fast in a monorepo\n\nThere are three strategies that we will use to make `tsc` fast:\n\n1.  `incremental` saves information about your project compilation into a file. The first time you run `tsc`, the compiler will create this file to make subsequent runs faster.\n2.  Parallelizing the type checking scripts in our workspaces.\n3.  Caching workspace tasks with our package manager so that we can ensure we never do the same work twice.\n\nPutting these techniques together, we'll be caching the type check task for entire workspaces so we hit cache for work we've already done **and** be as fast as possible when we miss the cache to check types.\n\n### Set up a TypeScript workspace\n\nLet's start by handling the `package.json` for our workspace. We'll need to install:\n\n1.  `typescript`\n2.  `@repo/tsconfig`, the package with our base TSConfig.\n\nAfter that we'll create a script for running `tsc` with the `--noEmit` flag so that the compiler _only_ checks types, skipping out on the actual compilation work.\n\n```json filename=\"packages/logger/package.json\" lang=\"json\"\n{\n  \"scripts\": {\n    \"typecheck\": \"tsc --noEmit\"\n  },\n  \"dependencies\": {\n    \"@repo/tsconfig\": \"workspace:*\" // Use \"*\" for npm or yarn\n  },\n  \"devDependencies\": {\n    \"typescript\": \"5.1.6\"\n  }\n}\n```\n\nNext, we'll create a `tsconfig.json` in our workspace where we'll extend from our base configuration:\n\n```json filename=\"packages/logger/tsconfig.json\" lang=\"json\"\n{\n  \"$schema\": \"https://json.schemastore.org/tsconfig\",\n  // focus(1:4)\n  \"extends\": \"@repo/tsconfig/base.json\", // Using our base config!\n  \"compilerOptions\": {\n    \"tsBuildInfoFile\": \"node_modules/.cache/tsbuildinfo.json\"\n  },\n  \"include\": [\".\"],\n  \"exclude\": [\"node_modules\"]\n}\n```\n\nMost of this file probably looks familiar. We're extending from our base TSConfig - but what's this `tsBuildInfoFile` property?\n\n`tsBuildInfoFile` tells the TypeScript compiler where to store the output of `incremental`. We're going to use the `.cache` folder in `node_modules` as this is a common practice for storing caches for libraries and dependencies.\n\nTest it out! (Using [globally installed `turbo`](https://turbo.build/repo/docs/installing#install-globally) for simplicity here)\n\n```sh filename=\"Terminal\"\ncd packages/logger\nturbo typecheck\n```\n\nIf all goes according to plan, you'll see your task ran by Turborepo in your terminal and a `tsbuildinfo.json` file in the `node_modules/.cache` directory of your workspace.\n\n### Build a Turborepo pipeline\n\nNow, we'll build our Turborepo pipeline with two important characteristics.\n\n```json filename=\"turbo.json\" lang=\"json\"\n{\n  \"pipeline\": {\n    \"topo\": {\n      \"dependsOn\": [\"^topo\"]\n    },\n    \"typecheck\": {\n      \"dependsOn\": [\"topo\"],\n      \"outputs\": [\"node_modules/.cache/tsbuildinfo.json\"]\n    }\n  }\n}\n```\n\n- **Recursively depending on `topo`**: This is [a little trick from the Turborepo documentation](https://turbo.build/repo/docs/core-concepts/monorepos/task-dependencies#dependencies-outside-of-a-task). In short, this `dependsOn` pattern flattens your task graph so that everything runs in parallel while still respecting changes in workspace dependencies. (If that sounds confusing, don't worry about it for now; just trust that it works. We'll be writing up a doc for this but, for the time being, let it be magic.) ✨\n- **Caching the output of `incremental`**: In the event that our task misses cache, we will still have the `tsbuildinfo.json` to use to speed up our task. Caching this file as a Turborepo `output` ensures that we have the `tsbuildinfo.json` shared across our machines as often as possible so we can use it in as many places as we can.\n\nWith these two optimizations, we've massively sped up the type checking task in your repository. We also have a base TSConfig that we will always use so our repository has uniformity that we can trust between individuals and teams.\n\nCongratulations, you are now friends with TypeScript.\n\n<Callout type=\"goodToKnow\">\n  <li>\n    You can create multiple files in your TSConfig workspace to extend from. You\n    may want to do this if you have specific needs (for instance, a certain\n    framework requires certain options). If you do create multiple files, you\n    may still find it advantageous to extend from a common base configuration in\n    those custom configurations..\n  </li>\n  <li>\n    You'll notice I didn't mention TypeScript's Project References. In a\n    Turborepo, you can usually avoid them. 😁\n  </li>\n</Callout>",
    "_meta": {
      "filePath": "lessons/guardrails/typescript.mdx",
      "fileName": "typescript.mdx",
      "directory": "lessons/guardrails",
      "extension": "mdx",
      "path": "lessons/guardrails/typescript"
    }
  },
  {
    "title": "Package managers",
    "sidebarOrderPosition": 3,
    "ogDescription": "Monorepo package managers",
    "content": "**We will be using pnpm throughout Maestros.** If you need to use a different package manager, we'll leave it to you to adjust accordingly.\n\n- [pnpm](/monorepos/package-managers/pnpm)\n- [yarn](/monorepos/package-managers/yarn)\n- [npm](/monorepos/package-managers/npm)\n\nYour package manager lays the foundation of your repository. It has two core responsibilities in your monorepo:\n\n- Handling dependencies\n- Establishing workspaces\n\n## Handling dependencies\n\n[The npm registry](https://www.npmjs.com/) contains many valuable external packages that you can leverage in building your applications. Additionally, you'll be building your own packages directly inside of your monorepo.\n\nYour package manager will help you install and use those dependencies for use throughout your project. Every package manager does this in slightly different ways and we'll make sure we understand those nuances to use the best package manager for our needs.\n\n## Establishing workspaces\n\nWe've discussed more deeply how workspaces work on [the Workspaces page](/monorepos/basics/workspaces) but it's worth noting here that the establishment of workspaces is your package manager's responsibility.\n\nIf you structure your repository as if it has workspaces **without** following the instructions for setting up workspaces for your package manager, you'll run into many problems.\n\nCheck out the page for your package manager for notes on how to create your workspaces.",
    "_meta": {
      "filePath": "lessons/package-managers/index.mdx",
      "fileName": "index.mdx",
      "directory": "lessons/package-managers",
      "extension": "mdx",
      "path": "lessons/package-managers"
    }
  },
  {
    "title": "npm",
    "sidebarOrderPosition": 2,
    "ogDescription": "Using npm in a monorepo",
    "content": "import { FileTree } from '#/components/FileTree';\n\n[npm](https://npmjs.com) was the first JavaScript package manager, setting the standard for all of the package managers that we have today. npm comes bundled with the Node.js runtime and is the default package manager for the JavaScript ecosystem and supports monorepos through workspaces.\n\n## Setting up workspaces\n\nTo create your workspaces, you'll need a `workspaces` field in your `package.json`:\n\n```json filename=\"package.json\"\n{\n  \"name\": \"my-repo\",\n  \"private\": true,\n  \"scripts\": { ... },\n  \"devDependencies\": { ... },\n  // focus(1:2)\n  \"packageManager\": \"npm@8.5.0\", // Needed for Turborepo\n  \"workspaces\": [\"apps/*\", \"packages/*\"]\n}\n```\n\nNow, any directory in your `apps` and `packages` directories that contains a `package.json` will be treated as a workspace.\n\n<FileTree>\n  <FileTree.File name=\"package.json\" />\n  <FileTree.File name=\"package-lock.json\" />\n  <FileTree.Folder name=\"apps\" open>\n    <FileTree.File name=\"docs (Workspace!)\" />\n    <FileTree.File name=\"web (Workspace!)\" />\n  </FileTree.Folder>\n  <FileTree.Folder name=\"packages\" open>\n    <FileTree.File name=\"logger (Workspace!)\" />\n    <FileTree.File name=\"ui (Workspace!)\" />\n  </FileTree.Folder>\n</FileTree>\n\nTo begin building packages, see [the packaging page](/monorepos/packaging).\n\nTo begin building apps, see the [applications page](/monorepos/packaging/applications).\n\n## Tips and tricks\n\n### Workspace-specific commands\n\nSay you want to run an npm command in a specific workspace. This can be done using the `--workspace` argument (`-w` for short). The value is your workspace's name from `package.json`.\n\n```bash filename=\"Terminal\"\nnpm install react -w @repo/ui\n```",
    "_meta": {
      "filePath": "lessons/package-managers/npm.mdx",
      "fileName": "npm.mdx",
      "directory": "lessons/package-managers",
      "extension": "mdx",
      "path": "lessons/package-managers/npm"
    }
  },
  {
    "title": "pnpm",
    "sidebarOrderPosition": 0,
    "ogDescription": "Using pnpm in a monorepo",
    "content": "[pnpm](https://pnpm.io/) is a package manager built with an emphasis on monorepos. This makes it our preferred choice in a monorepo for a few specific reasons:\n\n- **Speed**: pnpm can be up to two times faster than the other package managers.\n- **Correctness**: Other package managers are more willing to sacrifice strictness when it comes to workspace dependency boundaries. In a pnpm repository, package hoisting is less forgiving.\n- **Disk space efficiency**: Caching and deduplication in pnpm mean smaller project size on your hard drive.\n\n## Setting up workspaces\n\nTo create your workspaces, make a file in the root of your repository called `pnpm-workspace.yaml` and add the globs where your workspaces will be located:\n\n```yml filename=\"pnpm-workspace.yaml\"\npackages:\n  - apps/*\n  - packages/*\n  - tooling/*\n```\n\nNote that you pnpm will let you add nested workspaces using a `/**` double star syntax but Turborepo does not currently support this feature.\n\nIf you're using Turborepo, you'll also need to add a line to your root `package.json`:\n\n```json filename=\"package.json\"\n{\n  \"name\": \"my-repo\",\n  \"private\": true,\n  \"scripts\": { ... },\n  \"devDependencies\": { ... },\n  // focus(1:1)\n  \"packageManager\": \"pnpm@8.5.0\"\n}\n```\n\n## Migrating to pnpm\n\nIf you're migrating to pnpm from a different package manager, you may find that your repository starts to throw errors about not being able to find dependencies in certain workspaces.\n\nIt is very unlikely that you've found a bug in pnpm. Rather, pnpm may be finding a bug in your code.\n\nBecause pnpm resolves dependencies more strictly, you might have to do some debugging to learn why your dependencies are not being resolved. Common reasons include:\n\n- npm and yarn use an `*` to refer to workspace dependencies but pnpm uses `workspace:*`. Make sure your dependency follows the format `\"@repo/my-dep\": \"workspace:*`.\n- You're using a package in a workspace where it hasn't been installed. Because npm and yarn are more relaxed about module resolution, you can often use a package in a workspace where it is not explicitly installed into the workspace's `package.json`. Audit your dependency list to see if you need to install the package in the erroring workspace.\n\n## Tips and tricks\n\n### Bump an external package version in all workspaces\n\nYou'll often want to keep the same version of an external package consistent across your repository. For instance, you only have one version of React being used in your `ui` and `web` packages. Use this command to bump to the latest React version in all your workspaces:\n\n```bash filename=\"Terminal\"\npnpm -r up react@latest\n```\n\nYou can change the package and version tag that you're targeting to your liking!\n\n### Figure out where a package is being installed\n\nPackage dependencies trees can be hard to debug. Sometimes, you just want to figure out what a package is in your repository in the first place.\n\n```bash filename=\"Terminal\"\npnpm why react\n```\n\nThis command will show you everywhere in your dependency tree where `react` is being brought in and why.",
    "_meta": {
      "filePath": "lessons/package-managers/pnpm.mdx",
      "fileName": "pnpm.mdx",
      "directory": "lessons/package-managers",
      "extension": "mdx",
      "path": "lessons/package-managers/pnpm"
    }
  },
  {
    "title": "Yarn",
    "sidebarOrderPosition": 1,
    "ogDescription": "Using Yarn in a monorepo",
    "content": "import { FileTree } from '#/components/FileTree';\n// import { UnderConstruction } from '../../UnderConstruction';\n\n[yarn](https://yarnpkg.com) was the second package manager to be made after npm. Yarn introduced many innovations at the time including native monorepo support, caching, and lock files.\n\nThe first version of Yarn, now known as Yarn Classic, works similar to npm, installing bundled versions of package source code. But the second version of Yarn introduced a strategy called \"Plug 'n' Play\" as an effort to reduce installation times and use less desk space compared to `node_modules`.\n\n## Yarn Classic\n\n## Setting up workspaces\n\nTo create your workspaces, you'll need a `workspaces` field in your `package.json`:\n\n```json filename=\"package.json\"\n{\n  \"name\": \"my-repo\",\n  \"private\": true,\n  \"scripts\": { ... },\n  \"devDependencies\": { ... },\n  // focus(1:2)\n  \"packageManager\": \"yarn@1.22.15\", // Needed for Turborepo\n  \"workspaces\": [\"apps/*\", \"packages/*\"]\n}\n```\n\nNow, any directory in your `apps` and `packages` directories that contains a `package.json` will be treated as a workspace.\n\n<FileTree>\n  <FileTree.File name=\"package.json\" />\n  <FileTree.File name=\"package-lock.json\" />\n  <FileTree.Folder name=\"apps\" open>\n    <FileTree.File name=\"docs (Workspace!)\" />\n    <FileTree.File name=\"web (Workspace!)\" />\n  </FileTree.Folder>\n  <FileTree.Folder name=\"packages\" open>\n    <FileTree.File name=\"logger (Workspace!)\" />\n    <FileTree.File name=\"ui (Workspace!)\" />\n  </FileTree.Folder>\n</FileTree>\n\n## Tips and tricks\n\n### Interact with a specific workspace\n\nYou can run Yarn commands on a specific workspace using the `--workspace` command (or `-w`, for short).\n\n```bash filename=\"Terminal\"\nyarn add react -w ui\n```\n\nThis will install React to a workspace with the `\"name\": \"ui\"` in its `package.json`.\n\n### Figure out where a package is being installed\n\nPackage dependencies trees can be hard to debug. Sometimes, you just want to figure out what a package is in your repository in the first place.\n\n```bash filename=\"Terminal\"\nyarn why react\n```\n\nThis command will show you everywhere in your dependency tree where `react` is being brought in and why.\n\n## Yarn Berry\n\n{/* <UnderConstruction /> */}",
    "_meta": {
      "filePath": "lessons/package-managers/yarn.mdx",
      "fileName": "yarn.mdx",
      "directory": "lessons/package-managers",
      "extension": "mdx",
      "path": "lessons/package-managers/yarn"
    }
  },
  {
    "title": "Applications",
    "unpublished": true,
    "sidebarOrderPosition": 0,
    "ogDescription": "Building apps in your monorepo",
    "content": "// import { UnderConstruction } from '../../UnderConstruction';\n\n{/* <UnderConstruction /> */}",
    "_meta": {
      "filePath": "lessons/packaging/applications.mdx",
      "fileName": "applications.mdx",
      "directory": "lessons/packaging",
      "extension": "mdx",
      "path": "lessons/packaging/applications"
    }
  },
  {
    "title": "External Package",
    "sidebarOrderPosition": 3,
    "ogDescription": "Using the External Packages in a monorepo",
    "content": "External packages are those that you install from npm. You've probably been using these since the early days of your JavaScript career so we shouldn't have to explain too much about their fundamentals!\n\nWhat we will be interested in is how to install packages into the context of your workspaces. Let's take a look.\n\n## Always install where the package is needed\n\nWhen we're working in a monorepo, we have our workspaces creating different scopes within the repository. This means that it's highly probable that the package you're installing doesn't belong in the root of the repository.\n\nInstead, ensure that you install packages within the workspace(s) that they belong in. You can do this in a couple different ways.\n\n1. Run the install command while you are in your workspace's directory:\n\n```bash filename=\"Terminal\"\ncd apps/web\nnpm install react\n```\n\n2. Or use the workspace flag of your package manager:\n\n```bash filename=\"Terminal\"\npnpm install react --workspace=web\n```\n\nFor more on how to handle external packages with your package manager, see the page for your respective package manager under [Package Managers](/monorepos/package-managers)",
    "_meta": {
      "filePath": "lessons/packaging/external.mdx",
      "fileName": "external.mdx",
      "directory": "lessons/packaging",
      "extension": "mdx",
      "path": "lessons/packaging/external"
    }
  },
  {
    "title": "Compilation patterns",
    "sidebarOrderPosition": 5,
    "ogDescription": "Package compilation patterns in monorepos",
    "content": "Making the most out of your monorepo means ensuring that you're packaging your workspaces correctly. Our workspaces need to be given the correct configurations for code sharing and deployment.\n\nThere are three different strategies for compiling your packages within your monorepo:\n\n- [Internal Package](/monorepos/packaging/internal): Compile the source code for your workspace package in your monorepo and share it through installation into other workspaces. This strategy allows you to have hot-reloading for your packages in development and caching for your production builds.\n- [Just-In-Time Package](/monorepos/packaging/jit): If you'd like to avoid setting up a compiler, most modern frameworks can compile your packages _as they consume them_. While this strategy is easier to set up, it does come with the tradeoff that you won't be able to cache the build outputs for your packages.\n- [External packages](/monorepos/packaging/external): Pull your packages in from the npm registry. This strategy is likely what you want to move away from for any packages that you control the source code for but can still be useful in some scenarios. You'll be moving outside of a typical monorepo workflow in these situations. If you're unsure if a publishing your own external package is right for your monorepo, it probably isn't.",
    "_meta": {
      "filePath": "lessons/packaging/index.mdx",
      "fileName": "index.mdx",
      "directory": "lessons/packaging",
      "extension": "mdx",
      "path": "lessons/packaging"
    }
  },
  {
    "title": "Internal Package",
    "sidebarOrderPosition": 0,
    "ogDescription": "Using the Internal Package pattern in a monorepo.",
    "content": "import { Callout } from '#/components/Callout';\n\nInternal Packages are similar to [External Packages](/monorepos/packaging) in many ways:\n\n- Compiled: The package is compiled from its source code.\n- Specified entrypoint(s): The package has explicit places for you to access the functionality that the package provides.\n- Package manager-friendly: Installing packages with your package manager is an easy way to share code.\n\nHowever, Internal Packages are different in two important ways:\n\n- In-repo source code: The code that makes up the package is in your repository, making it highly discoverable, accessible, and editable.\n- One version: When installing to other workspaces within your repository, you'll use `\"*\"` (or `\"workspace:*\"` for pnpm). This means you'll always use whatever the current version of the code that is in your repository.\n\nWhen you compile a package in your Turborepo, you can cache your compilation outputs for sub-second build times. Build your source code once; never build it again.\n\nLet's take a look at what it takes to build an Internal Package for UI component library with React and TypeScript.\n\n## Create a workspace\n\nWe first need to lay the foundation for our workspace. We can do so in a few quick steps.\n\n### Make sure our package manager sees the workspace\n\nEstablish a workspace by following [the workspace instructions for your package manager](/monorepos/package-managers).\n\n### Add our `tsconfig.json`\n\nWe'll be making a TypeScript package so we need to have a `tsconfig.json`. If you've read [the Typescript reference](/monorepos/guardrails/typescript) already, this will look familiar:\n\n```json filename=\"packages/ui/tsconfig.json\"\n{\n  \"$schema\": \"https://json.schemastore.org/tsconfig\",\n  \"extends\": \"@repo/tsconfig/react-library.json\",\n  \"compilerOptions\": {\n    \"tsBuildInfoFile\": \"node_modules/.cache/tsbuildinfo.json\",\n    \"outDir\": \"dist\"\n  },\n  \"include\": [\".\"],\n  \"exclude\": [\"dist\", \"node_modules\"]\n}\n```\n\nThere are a few important properties that you'll want to make sure you include in either your base `tsconfig` or here in your package's `tsconfig.json` to have the smoothest experience:\n\n- `\"declaration\": true`: Create `.d.ts` files for your compiled JavaScript so your package has types when imported by other workspaces.\n- `\"declarationMap\": true`: Generates maps between your type declarations and JavaScript files. This allows your editor to jump to the source code rather than your `.d.ts` file when you use Go To Definition.\n- `\"outDir\": \"dist\"`: The location where your TypeScript declaration files will be created. You want this to be the same as where your .\n\nAll of these configurations will add up to a perfect TypeScript experience once we get to our compilation step.\n\n### Add a `package.json`\n\nCreate a `package.json` in your workspace directory. We'll fill in `\"exports\"` and `\"scripts\"` step-by-step later so we can understand what they do, piece-by-piece.\n\n```json filename=\"packages/ui/package.json\"\n{\n  \"name\": \"@repo/ui\",\n  \"version\": \"0.1.0\", // Arbitrary for Internal Packages\n  \"private\": true, // Prevents npm publishing\n  \"exports\": {}, // Entrypoints for your application\n  \"scripts\": {}, // Tasks for the package\n  \"dependencies\": {\n    \"react\": \"^18.2.0\"\n  },\n  \"devDependencies\": {\n    \"@repo/tsconfig\": \"workspace:*\",\n    \"@types/react\": \"^18.2.20\",\n    \"@types/react-dom\": \"^18.2.0\",\n    \"tsup\": \"^7.2.0\", // Bundler for compilation\n    \"typescript\": \"^5.1.6\"\n  }\n}\n```\n\nAt this point, hit the install command for your package manager to get the packages installed.\n\n## Create some source code\n\nWe'll use an `src` folder in our workspace to keep things tidy. Create your first UI component in an index file:\n\n```tsx filename=\"packages/ui/src/index.tsx\"\nexport const Button = (props: { text: string }) => {\n  return <button>{props.text}</button>;\n};\n```\n\n## Prepare for compilation\n\nWe'll need to get our TypeScript compiled to JavaScript so our applications and packages can consume our code. For this, we like to use [`tsup`](https://tsup.egoist.dev), a bundler that gives us a simple yet powerful bundling API with `esbuild` under the hood.\n\n### Make a `tsup` configuration file\n\nWe want to be able to compile our package the same way whether we are building in watch mode for development or building for production. `tsup` can read from a `tsup.config.js` file to give us a consistent configuration to use:\n\n```js filename=\"packages/ui/tsup.config.js\" note=\"We're using JavaScript here but will still get great autocomplete. 😄\"\nimport { defineConfig } from 'tsup';\nimport { exec } from 'child_process';\n\nexport default defineConfig((options) => ({\n  entry: ['src/index.tsx'], // Where your source code lives (can provide multiple entries)\n  splitting: false,\n  treeshake: true,\n  clean: true,\n  outDir: 'dist', // Where you want your compiled files to live\n  onSuccess: async () => {\n    exec('tsc --emitDeclarationOnly');\n  },\n  ...options,\n}));\n```\n\nNotice the important `onSuccess` function here. It's responsible for giving us TypeScript declaration files so that our editor will jump to our TypeScript source code instead of our compiled JavaScript. [tsup is unable to generate these files](https://tsup.egoist.dev/#generate-typescript-declaration-maps--d-ts-map) but, luckily, the TypeScript compiler handles these pretty quickly.\n\n### Make a build and dev script\n\nHead back to your `package.json` and add some scripts:\n\n```json filename=\"packages/ui/package.json\"\n{\n  \"name\": \"@repo/ui\",\n  \"version\": \"0.1.0\", // Arbitrary for Internal Packages\n  \"private\": true, // Prevents npm publishing\n  \"exports\": {}, // Entry points for your application\n    // focus(1:4)\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"dev\": \"tsup --watch\"\n  },\n  \"dependencies\": {...},\n  \"devDependencies\": {...}\n}\n```\n\n### Ensure your dist will be gitignored\n\nYou'll want to make sure you aren't committing your builds to source control. If you haven't done so yet, add `dist` to your `.gitignore`:\n\n## Set up your exports\n\n`exports` is where we define the entry points to our package. Workspaces that consume your Internal Package will use these as the places that they can import code from.\n\nTo create the entrypoint, we'll fill in the `\"exports\"` field of the `package.json`:\n\n```json filename=\"packages/ui/package.json\"\n{\n  \"name\": \"@repo/ui\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n    // focus(1:6)\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\"\n    }\n  },\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"dev\": \"tsup -w\"\n  },\n  \"dependencies\": {...},\n  \"devDependencies\": {...}\n}\n```\n\n## Compile your code\n\nWe should be ready now! Run `turbo build --filter=ui` in your terminal and check your new `ui` package to find a `dist` folder full of `.d.ts` and `.js` files.\n\nWe'll now be able to import our code in an application once we install it to its workspace:\n\n```ts filename=\"apps/web/src/index.ts\"\nimport { Button } from '@repo/ui';\n```\n\n## Iteration speed: Unlocked\n\nYou'll now be able to continually update this package much faster than if you needed to publish it to npm since it will be right there alongside the rest of the code for your applications. If you, for example, change a TypeScript interface in your UI package, you'll instantly be able to find any mistypings in your application the next time you run `turbo typecheck`.\n\nIf you'd like to build conformance into your new UI package, be sure to follow along with the references in [the Guardrails pages](/monorepos/guardrails).",
    "_meta": {
      "filePath": "lessons/packaging/internal.mdx",
      "fileName": "internal.mdx",
      "directory": "lessons/packaging",
      "extension": "mdx",
      "path": "lessons/packaging/internal"
    }
  },
  {
    "title": "Just-In-Time Package",
    "sidebarOrderPosition": 1,
    "ogDescription": "Using Just-In-Time Packages in a monorepo",
    "content": "Using Just-in-Time Packages is a great way to reduce the configuration complexity of your repository. Using a Just-In-Time Package allows you to directly consume TypeScript into applications without having to pre-compile them. Instead, the applications themselves will compile the TypeScript packages when they build for production.\n\nWhile this approach is much simpler to set up, it does come with one drawback when using Turborepo: Because your package does not have build outputs, you won't be able to cache the build step for your package. This is a simple tradeoff of simplicity vs. build times. If you're interested in improving your build times, [take a look at the Internal Packages page](/monorepos/packaging/internal) to add a cacheable build step.\n\nLet's take a look at what this looks like by building a UI components package with React and Typescript.\n\n## Create a workspace\n\nWe first need to lay the foundation for our workspace. We can do so in a few quick steps.\n\n### Make sure our package manager sees the workspace\n\nEstablish a workspace by following [the workspace instructions for your package manager](/monorepos/package-managers).\n\n### Add our `tsconfig.json`\n\nWe'll be making a TypeScript package so we need to have a `tsconfig.json`. If you've read [the Typescript reference](/monorepos/guardrails/typescript) already, this will look familiar:\n\n```json filename=\"packages/ui/tsconfig.json\"\n{\n  \"$schema\": \"https://json.schemastore.org/tsconfig\",\n  \"extends\": \"@repo/tsconfig/react-library.json\",\n  \"compilerOptions\": {\n    \"tsBuildInfoFile\": \"node_modules/.cache/tsbuildinfo.json\",\n    \"outDir\": \"dist\"\n  },\n  \"include\": [\".\"],\n  \"exclude\": [\"dist\", \"node_modules\"]\n}\n```\n\n### Create an entrypoint to your code\n\nNow, we'll create an entrypoint to our code so that other applications and packages can import it.\n\nThe `\"exports\"` field make the code available for compilation while the `\"typesVersions\"` field makes the type definitions available.\n\n```json filename=\"packages/ui/package.json\"\n{\n  \"name\": \"@repo/ui\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  //focus(1:8)\n  \"exports\": {\n    \".\": \"./src/index.tsx\"\n  },\n  \"typesVersions\": {\n    \"*\": {\n      \"*\": [\"./src/index.tsx\"]\n    }\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {}\n}\n```\n\nThat's it! We don't need to worry about compiling this code because we're going to have the consuming applications compile them in the next step.\n\n## Tell your applications to compile TypeScript packages\n\nIf you see an error that says,\n\n```\nModule parse failed: Unexpected token (5:9)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file.\n```\n\nThis means that your TypeScript dependencies didn't get transpiled.\n\nModern frameworks use powerful compilers and bundlers that can automatically transpile TypeScript source code - even if that code is outside the application's context!\n\nLet's take a look at how a few of the ones do this.\n\n### Vite\n\nVite handles TypeScript packages out of the box! No configuration required!\n\n### Next.js\n\nFor Next.js to transpile your external TypeScript code, you'll need to add a `transpilePackages` to your `next.config.js`:\n\n```js filename=\"next.config.js\"\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  transpilePackages: ['@repo/ui'],\n};\n\nmodule.exports = nextConfig;\n```\n\nFor more, [visit the documentation](https://nextjs.org/docs/app/api-reference/next-config-js/transpilePackages).\n\n### Vue\n\nVue can transpile your packages on-the-fly by adding `transpileDependencies` to your `vue.config.js`:\n\n```js filename=\"vue.config.js\"\nmodule.exports = {\n  transpileDependencies: ['@repo/ui'],\n};\n```\n\nFor more, [visit the documentation](https://cli.vuejs.org/config/#transpiledependencies).",
    "_meta": {
      "filePath": "lessons/packaging/jit.mdx",
      "fileName": "jit.mdx",
      "directory": "lessons/packaging",
      "extension": "mdx",
      "path": "lessons/packaging/jit"
    }
  },
  {
    "title": "Multiple Entrypoint Package",
    "sidebarOrderPosition": 5,
    "ogDescription": "Using the Internal Package pattern in a monorepo.",
    "content": "Using the knowledge we gained in the [Internal Packages](/monorepos/packaging/internal) and [Just-In-Time Packages](/monorepos/packaging/jit), we can easily create packages with multiple entrypoints.\n\n## Motivation\n\nThere could be several reasons that you'd want to create your package with multiple entrypoints:\n\n- **Runtime Constraints**: In some cases, a Node package that makes it into the browser bundle can crash your application since it won't have server-side only APIs available. By splitting the imports into two separate entrypoints, you can create server-friendly and browser-friendly entrypoints.\n- **Organization**: There are often opportunities to bring clarity to your code by splitting your imports amongst multiple entrypoints. We'll give you an example by building a UI component library down the rest of this page.\n\n## Add an entrypoint to an Internal Package\n\nTo pick up where we left off at the end of the [Internal Packages](/monorepos/packaging/internal) page, we had a transpiled package that we could share to the rest of our workspaces with one entrypoint.\n\nTo give this package another entrypoint, we'll only need to make a few small changes.\n\n### Add some source code\n\nLet's add another file to our source code for a couple icons:\n\n```tsx filename=\"packages/ui/src/icons.tsx\"\nexport const Circle = (props: SVGAttributes<SVGElement>) => {\n  return (\n    <svg {...props} viewBox=\"0 0 50 50\">\n      <circle cx=\"25\" cy=\"25\" r=\"20\" />\n    </svg>\n  );\n};\n\nexport const Square = (props: SVGAttributes<SVGElement>) => {\n  return (\n    <svg {...props} viewBox=\"0 0 50 50\">\n      <rect x=\"10\" y=\"10\" width=\"30\" height=\"30\" />\n    </svg>\n  );\n};\n```\n\n### Add the `tsup` entrypoint\n\nNext, we'll need to make `tsup` aware of the new entry to your package.\n\n```js filename=\"packages/ui/tsup.config.js\" note=\"We're using JavaScript here but will still get great autocomplete. 😄\"\nexport default defineConfig((options) => ({\n  entry: [\n    \"src/index.tsx\",\n    // focus(1:1)\n    \"src/icons.tsx\"\n    ]\n  ...\n}));\n```\n\n### Add a new entry to `exports`\n\nLast, we'll add the entrypoint to our `package.json`.\n\n```json filename=\"packages/ui/package.json\"\n{\n  \"name\": \"@repo/ui\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\"\n    },\n      // focus(1:4)\n    \"./icons\": {\n      \"types\": \"./dist/icons.d.ts\",\n      \"import\": \"./dist/icons.js\"\n    }\n  },\n  ...\n}\n```\n\nYou'll now be able to import from the entrypoint using:\n\n```tsx filename=\"apps/web/src/index.tsx\"\nimport { Circle } from '@repo/ui/icons';\n```\n\n## Adding an entrypoint to a Just-In-Time Package\n\nTo pick up where we left off at the end of [the Just-In-Time Package page](/monorepos/packaging/jit), we can add another entrypoint in two quick steps.\n\n### Add some source code\n\nLet's add another file to our source code for a couple icons:\n\n```tsx filename=\"packages/ui/src/icons.tsx\"\nexport const Circle = (props: SVGAttributes<SVGElement>) => {\n  return (\n    <svg {...props} viewBox=\"0 0 50 50\">\n      <circle cx=\"25\" cy=\"25\" r=\"20\" />\n    </svg>\n  );\n};\n\nexport const Square = (props: SVGAttributes<SVGElement>) => {\n  return (\n    <svg {...props} viewBox=\"0 0 50 50\">\n      <rect x=\"10\" y=\"10\" width=\"30\" height=\"30\" />\n    </svg>\n  );\n};\n```\n\n### Add a new entry to `exports`\n\nNow, we'll create another entrypoint to our code so that other applications and packages can import it directly.\n\n```json filename=\"packages/ui/package.json\"\n{\n  \"name\": \"@repo/ui\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"exports\": {\n    \".\": \"./src/index.tsx\",\n    //focus(1:1)\n    \"./icons\": \"./src/icons.tsx\"\n  },\n  \"typesVersions\": {\n    \"*\": {\n      \"*\": [\"./src/index.tsx\"],\n      //focus(1:1)\n      \"icons\": [\"./src/icons.tsx\"]\n    }\n  }\n}\n```\n\nThe `\"exports\"` field make the code available for compilation while the `\"typesVersions\"` field makes the type definitions available.\n\nYou'll now be able to import from the entrypoint using:\n\n```tsx filename=\"apps/web/src/index.tsx\"\nimport { Circle } from '@repo/ui/icons';\n```",
    "_meta": {
      "filePath": "lessons/packaging/multiple.mdx",
      "fileName": "multiple.mdx",
      "directory": "lessons/packaging",
      "extension": "mdx",
      "path": "lessons/packaging/multiple"
    }
  },
  {
    "title": "Auth.js?",
    "unpublished": true,
    "sidebarOrderPosition": 9,
    "ogDescription": "Using Auth.js in a monorepo",
    "content": "// import { UnderConstruction } from '../../UnderConstruction';\n\n{/* <UnderConstruction /> */}",
    "_meta": {
      "filePath": "lessons/tools/authjs.mdx",
      "fileName": "authjs.mdx",
      "directory": "lessons/tools",
      "extension": "mdx",
      "path": "lessons/tools/authjs"
    }
  },
  {
    "title": "Drizzle?",
    "unpublished": true,
    "sidebarOrderPosition": 5,
    "ogDescription": "Using Drizzle in a monorepo",
    "content": "// import { UnderConstruction } from '../../UnderConstruction';\n\n{/* <UnderConstruction /> */}",
    "_meta": {
      "filePath": "lessons/tools/drizzle.mdx",
      "fileName": "drizzle.mdx",
      "directory": "lessons/tools",
      "extension": "mdx",
      "path": "lessons/tools/drizzle"
    }
  },
  {
    "title": "GraphQL?",
    "unpublished": true,
    "sidebarOrderPosition": 6,
    "ogDescription": "Using GraphQL in a monorepo",
    "content": "// import { UnderConstruction } from '../../UnderConstruction';\n\n{/* <UnderConstruction /> */}",
    "_meta": {
      "filePath": "lessons/tools/graphql.mdx",
      "fileName": "graphql.mdx",
      "directory": "lessons/tools",
      "extension": "mdx",
      "path": "lessons/tools/graphql"
    }
  },
  {
    "title": "More tools",
    "unpublished": true,
    "sidebarOrderPosition": 7,
    "ogDescription": "Use your favorite tools in a monorepo",
    "content": "// import { UnderConstruction } from '../UnderConstruction';\n\n{/* <UnderConstruction /> */}",
    "_meta": {
      "filePath": "lessons/tools/index.mdx",
      "fileName": "index.mdx",
      "directory": "lessons/tools",
      "extension": "mdx",
      "path": "lessons/tools"
    }
  },
  {
    "title": "Next.js",
    "sidebarOrderPosition": 3,
    "ogDescription": "Using Next.js in a monorepo",
    "content": "Using Next.js in a monorepo is a great way to give your Next.js applications even more superpowers.\n\n## Want easy mode?\n\nIf you prefer, you can [clone the monorepo for Maestros](https://github.com/anthonyshew/maestros.git) (remember to star the repo while you're there!) and use the application found in `apps/starter-nextjs`. Remove any apps you don't want and you're good to go!\n\n## Getting started\n\nIn your `apps` directory, use `create-next-app` to create a new Next.js app:\n\n```bash filename=\"Terminal\"\ncd apps\nnpx create-next-app@latest\n```\n\nAdd a `turbo.json` to your new app's directory, configured for Next.js:\n\n```json filename=\"apps/my-app/turbo.json\" note=\"Please refer to the docs at turbo.build/repo/docs/reference/configuration for details on the keys seen here.\"\n{\n  \"extends\": [\"//\"],\n  \"pipeline\": {\n    \"build\": {\n      \"outputs\": [\"./next/**\", \"!./next/cache/**\"],\n      \"dotEnv\": [\n        \".env.production.local\",\n        \".env.local\",\n        \".env.production\",\n        \".env\"\n      ],\n      \"env\": [\n        // Add your environment variables!\n      ]\n    },\n    \"dev\": {\n      \"persistent\": true,\n      \"dotEnv\": [\n        \".env.development.local\",\n        \".env.local\",\n        \".env.development\",\n        \".env\"\n      ]\n    },\n    \"lint\": {\n      \"outputs\": [\"node_modules/.cache/.eslintcache\"]\n    },\n    \"lint:fix\": {\n      \"outputs\": [\"node_modules/.cache/.eslintcache\"],\n      \"cache\": false\n    },\n    \"format\": {\n      \"outputs\": [\"node_modules/.cache/.prettiercache\"]\n    },\n    \"format:fix\": {\n      \"outputs\": [\"node_modules/.cache/.prettiercache\"],\n      \"cache\": false\n    },\n    \"typecheck\": {\n      \"outputs\": [\"node_modules/.cache/tsbuildinfo.json\"],\n      \"outputMode\": \"errors-only\"\n    }\n  }\n}\n```\n\nThen, use the install command for your package manager. Your new app is now a part of your graph!\n\n## Adding your configurations\n\nIf you've followed the [Prettier](monorepos/guardrails/prettier), [ESLint](/monorepos/guardrails/eslint), and [TypeScript](/monorepos/guardrails/typescript) pages here in Maestros, you'll want to integrate the configuration from these packages into your Next.js app. Let's get those incorporated in one by one.\n\n### Prettier\n\nFirst, add the scripts to `package.json`:\n\n```json filename=\"apps/my-app/package.json\"\n{\n  \"scripts\": {\n    \"format\": \"prettier . --check --cache --cache-location='node_modules/.cache/prettiercache'\",\n    \"format:fix\": \"prettier . --write --cache --cache-location='node_modules/.cache/prettiercache' --log-level=warn\"\n  },\n  \"devDependencies\": {\n    // Replace latest with most recent version\n    \"prettier\": \"latest\"\n  }\n}\n```\n\nPrettier will use the configuration found in the root of your monorepo - but it won't respect the `.prettierignore` found there. That's okay, though, because we can add one within our application's directory so we can make sure we don't spend time formatting files we don't need to.\n\n```text filename=\"apps/my-app/.prettierignore\"\n.env*\nnode_modules\n.next\n```\n\n### TypeScript\n\nFirst, install [your TSConfig presets](/monorepos/guardrails/typescript) to your application and making a type checking script:\n\n```json filename=\"apps/my-app/package.json\"\n{\n  \"scripts\": {\n    \"typecheck\": \"tsc --noEmit\"\n  },\n  \"devDependencies\": {\n    \"@repo/tsconfig\": \"workspace:*\", // or \"*\" for npm and yarn\n    // Replace latest with most recent version\n    \"typescript\": \"latest\"\n  }\n}\n```\n\n`create-next-app` will generate a `tsconfig.json` for you (as long as you picked TypeScript) so we will extend off of our root configurations there:\n\n```json filename=\"apps/my-app/tsconfig.json\"\n{\n  // focus(1:1)\n  \"extends\": \"@repo/tsconfig/nextjs.json\",\n  \"compilerOptions\": {\n    \"tsBuildInfoFile\": \"node_modules/.cache/tsbuildinfo.json\",\n    \"plugins\": [{ \"name\": \"next\" }],\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"#/*\": [\"./*\"]\n    }\n  },\n  \"include\": [\n    \"next-env.d.ts\",\n    \"**/*.js\",\n    \"**/*.ts\",\n    \"**/*.tsx\",\n    \".next/types/**/*.ts\",\n    \"next.config.js\"\n  ],\n  \"exclude\": [\"node_modules\", \".next\"]\n}\n```\n\n### ESLint\n\nUsing [our Next.js preset](/monorepos/guardrails/eslint#creating-presets) we can quickly have ESLint set up exactly like the rest of our Next.js apps.\n\nAdd ESLint and its scripts to your application's `package.json`:\n\n```json filename=\"apps/my-app/package.json\"\n{\n  \"scripts\": {\n    \"lint\": \"eslint . --cache --cache-location 'node_modules/.cache/.eslintcache' --max-warnings 0\",\n    \"lint:fix\": \"eslint . --fix --cache --cache-location 'node_modules/.cache/.eslintcache' --max-warnings 0\"\n  },\n  \"devDependencies\": {\n    \"@repo/lint\": \"workspace:*\", // or \"*\" for npm and yarn\n    // Replace latest with most recent version\n    \"eslint\": \"latest\"\n  }\n}\n```\n\nThen, integrate your configuration into `eslintrc.js`:\n\n```js filename=\"apps/my-app/eslintrc.js\" note=\"If you're not using TypeScript, you can remove parserOptions and plugins.\"\n/** @type {import(\"eslint\").Linter.Config} */\nmodule.exports = {\n  root: true,\n  extends: [require.resolve('@repo/lint/next.js')],\n  parserOptions: {\n    project: true,\n  },\n  plugins: ['@typescript-eslint'],\n};\n```\n\n## Using your UI package\n\nIf you're following the [Just-in-Time Package Pattern](/monorepos/packaging/jit), you'll want to make sure that Next.js knows to compile your UI components on the fly. To do this, we'll use the [transpilePackages](https://nextjs.org/docs/app/api-reference/next-config-js/transpilePackages) property in our Next.js configuration.\n\n```js filename=\"next.config.js\"\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  transpilePackages: ['@repo/ui'],\n};\n\nmodule.exports = nextConfig;\n```\n\nNow, our Next.js app will hot reload any changes in our UI workspace, seamlessly integrating our components into our Next.js development server.\n\n### Using framework-specific components in your UI package\n\nYou may find moments where you'd like to use Next.js-specific components as a part of your UI kit. Rather than installing Next.js into your UI component workspace, it's better to keep your components unaware of Next.js and pass the Next.js components as props to your UI component.\n\nAs an example, let's say you wanted to use `next/link` in your application using styles you've written out in your UI components. You'd first need to create a UI component that can accept `Link` from `'next/link'` as a prop:\n\n```tsx filename=\"packages/ui/src/MyLink.ts\"\nexport const MyLink = ({ linkComponent, children, ...props }) => {\n  const Component = linkComponent;\n  return <Component {...props}>{children}</Component>;\n};\n```\n\nAnd use it in your app like this:\n\n```tsx filename=\"apps/my-app/app/page.tsx\"\nimport { MyLink } from '@repo/ui';\nimport Link from 'next/link';\n\nexport default function Page() {\n  return (\n    <MyLink linkComponent={Link} href=\"/about\">\n      Click me!\n    </MyLink>\n  );\n}\n```\n\n### With Tailwind\n\nWe like to let the application compile Tailwind classes for us to keep things simple. We've written more about this pattern and why we do it that way on [the Tailwind page](/monorepos/tools/tailwind).",
    "_meta": {
      "filePath": "lessons/tools/nextjs.mdx",
      "fileName": "nextjs.mdx",
      "directory": "lessons/tools",
      "extension": "mdx",
      "path": "lessons/tools/nextjs"
    }
  },
  {
    "title": "Prisma?",
    "unpublished": true,
    "sidebarOrderPosition": 4,
    "ogDescription": "Using Prisma in a monorepo",
    "content": "// import { UnderConstruction } from '../../UnderConstruction';\n\n{/* <UnderConstruction /> */}",
    "_meta": {
      "filePath": "lessons/tools/prisma.mdx",
      "fileName": "prisma.mdx",
      "directory": "lessons/tools",
      "extension": "mdx",
      "path": "lessons/tools/prisma"
    }
  },
  {
    "title": "Sentry?",
    "unpublished": true,
    "sidebarOrderPosition": 7,
    "ogDescription": "Using Sentry in a monorepo",
    "content": "// import { UnderConstruction } from '../../UnderConstruction';\n\n{/* <UnderConstruction /> */}",
    "_meta": {
      "filePath": "lessons/tools/sentry.mdx",
      "fileName": "sentry.mdx",
      "directory": "lessons/tools",
      "extension": "mdx",
      "path": "lessons/tools/sentry"
    }
  },
  {
    "title": "Tailwind?",
    "unpublished": true,
    "sidebarOrderPosition": 0,
    "ogDescription": "Using Tailwind in a monorepo",
    "content": "// import { UnderConstruction } from '../../UnderConstruction';\n\n{/* <UnderConstruction /> */}",
    "_meta": {
      "filePath": "lessons/tools/tailwind.mdx",
      "fileName": "tailwind.mdx",
      "directory": "lessons/tools",
      "extension": "mdx",
      "path": "lessons/tools/tailwind"
    }
  },
  {
    "title": "tRPC?",
    "unpublished": true,
    "sidebarOrderPosition": 8,
    "ogDescription": "Using tRPC in a monorepo",
    "content": "// import { UnderConstruction } from '../../UnderConstruction';\n\n{/* <UnderConstruction /> */}",
    "_meta": {
      "filePath": "lessons/tools/trpc.mdx",
      "fileName": "trpc.mdx",
      "directory": "lessons/tools",
      "extension": "mdx",
      "path": "lessons/tools/trpc"
    }
  },
  {
    "title": "Vite (React)",
    "sidebarOrderPosition": 1,
    "ogDescription": "Using Vite for React in a monorepo",
    "content": "## Want easy mode?\n\nIf you prefer, you can [clone the monorepo for Maestros](https://github.com/anthonyshew/maestros.git) (remember to star the repo while you're there!) and use the application found in `apps/starter-vite`. Remove any apps you don't want and you're good to go!\n\n## Getting started\n\nCreate an app with Vite's scaffolder in your `apps` folder:\n\n```bash filename=\"Terminal\"\ncd apps\npnpm create vite\n```\n\nWe'll also add a `turbo.json` to ensure all of our pipelines are set for this app:\n\n```json filename=\"apps/starter-vite/turbo.json\"\n{\n  \"$schema\": \"https://turbo.build/schema.json\",\n  \"extends\": [\"//\"],\n  \"pipeline\": {\n    \"build\": {\n      \"dependsOn\": [\"^build\"],\n      \"outputs\": [\"dist/**\"],\n      \"dotEnv\": [\n        \".env.production.local\",\n        \".env.production\",\n        \".env.local\",\n        \".env\"\n      ]\n    },\n    \"lint\": {},\n    \"dev\": {\n      \"cache\": false,\n      \"persistent\": true,\n      \"dotEnv\": [\n        \".env.production.local\",\n        \".env.production\",\n        \".env.local\",\n        \".env\"\n      ]\n    }\n  }\n}\n```\n\n## Adding your configurations\n\nIf you've followed the [Prettier](monorepos/guardrails/prettier), [ESLint](/monorepos/guardrails/eslint), and [TypeScript](/monorepos/guardrails/typescript) pages here in Maestros, you'll want to integrate the configuration from these packages into your Vite app. Let's get those incorporated in one by one.\n\n### Prettier\n\nFirst, add the scripts to `package.json`:\n\n```json filename=\"apps/my-app/package.json\"\n{\n  \"scripts\": {\n    \"format\": \"prettier . --check --cache --cache-location='node_modules/.cache/prettiercache'\",\n    \"format:fix\": \"prettier . --write --cache --cache-location='node_modules/.cache/prettiercache' --log-level=warn\"\n  },\n  \"devDependencies\": {\n    // Replace latest with most recent version\n    \"prettier\": \"latest\"\n  }\n}\n```\n\nPrettier will use the configuration found in the root of your monorepo - but it won't respect the `.prettierignore` found there. That's okay, though, because we can add one within our application's directory so we can make sure we don't spend time formatting files we don't need to.\n\n```text filename=\"apps/my-app/.prettierignore\"\n.env*\nnode_modules\ndist\n```\n\n### TypeScript\n\nFirst, install [your TSConfig presets](/monorepos/guardrails/typescript) to your application and making a type checking script:\n\n```json filename=\"apps/my-app/package.json\"\n{\n  \"scripts\": {\n    \"typecheck\": \"tsc --noEmit\"\n  },\n  \"devDependencies\": {\n    \"@repo/tsconfig\": \"workspace:*\", // or \"*\" for npm and yarn\n    // Replace latest with most recent version\n    \"typescript\": \"latest\"\n  }\n}\n```\n\nCreating your Vite app using the scaffolder will generate two TypeScript configuration files (as long as you picked TypeScript), one for your application and one for `vite.config.ts`. We want to use our root configurations so we have more standardization for our TypeScript across our repository.\n\nIf you haven't yet, abstract these generated files into your TypeScript configuration package:\n\n- [`vite.json` example](https://github.com/anthonyshew/maestros/blob/main/tooling/typescript-config/vite.json)\n\n- [`vite.node.json` example](https://github.com/anthonyshew/maestros/blob/main/tooling/typescript-config/vite.node.json)\n\nAnd use them in your TypeScript Configurations in your application:\n\n```json filename=\"apps/starter-vite/tsconfig.json\"\n{\n  // focus(1:1)\n  \"extends\": \"@repo/tsconfig/vite.json\"\n}\n```\n\n```json filename=\"apps/starter-vite/tsconfig.node.json\"\n{\n  // focus(1:1)\n  \"extends\": \"@repo/tsconfig/vite.node.json\"\n}\n```\n\n### ESLint\n\nUsing [our Vite preset](/monorepos/guardrails/eslint#creating-presets) we can quickly have ESLint set up exactly like the rest of our Vite apps.\n\nAdd ESLint and its scripts to your application's `package.json`:\n\n```json filename=\"apps/starter-vite/package.json\"\n{\n  \"scripts\": {\n    \"lint\": \"eslint . --cache --cache-location 'node_modules/.cache/.eslintcache' --max-warnings 0\",\n    \"lint:fix\": \"eslint . --fix --cache --cache-location 'node_modules/.cache/.eslintcache' --max-warnings 0\"\n  },\n  \"devDependencies\": {\n    \"@repo/lint\": \"workspace:*\", // or \"*\" for npm and yarn\n    // Replace latest with most recent version\n    \"eslint\": \"latest\"\n  }\n}\n```\n\nThen, integrate your configuration into `eslintrc.js`:\n\n```js filename=\"apps/starter-vite/eslintrc.js\" note=\"If you're not using TypeScript, you can remove parserOptions and plugins.\"\n/** @type {import(\"eslint\").Linter.Config} */\nmodule.exports = {\n  root: true,\n  extends: [require.resolve('@repo/lint/vite.js')],\n  parserOptions: {\n    project: true,\n  },\n  plugins: ['@typescript-eslint'],\n};\n```\n\n## Using your UI package\n\nVite will compile TypeScript on-the-fly with zero-configuration so it doesn't matter what [packaging pattern](/monorepos/packaging) we are using. Install it into your Vite app and start building!\n\n### With Tailwind\n\nWe like to let the application compile Tailwind classes for us to keep things simple. We've written more about this pattern and why we do it that way on [the Tailwind page](/monorepos/tools/tailwind).",
    "_meta": {
      "filePath": "lessons/tools/vite.mdx",
      "fileName": "vite.mdx",
      "directory": "lessons/tools",
      "extension": "mdx",
      "path": "lessons/tools/vite"
    }
  },
  {
    "title": "Vitest?",
    "unpublished": true,
    "sidebarOrderPosition": 2,
    "ogDescription": "Using Vitest in a monorepo",
    "content": "// import { UnderConstruction } from '../../UnderConstruction';\n\n{/* <UnderConstruction /> */}",
    "_meta": {
      "filePath": "lessons/tools/vitest.mdx",
      "fileName": "vitest.mdx",
      "directory": "lessons/tools",
      "extension": "mdx",
      "path": "lessons/tools/vitest"
    }
  },
  {
    "title": "Try it out",
    "sidebarOrderPosition": 1,
    "ogDescription": "Feel the power of a monorepo in less than three minutes",
    "content": "If you've never worked with a monorepo before, I want you to see what it's like in 4 terminal commands and less than 2 minutes. Let's use a pre-built monorepo that you can quickly feel the power of.\n\n## Your first monorepo\n\nFirst, grab the starter monorepo from Turborepo.\n\n## Build two applications...at the same time\n\nNext, build the applications in the repository.\n\nIn your terminal, you will see logs for the two Next.js applications being built in parallel. This is great! Instead of building the first one and then the second one, we're building both.\n\n## Build them again in less than a second\n\nAlright, now run the builds again using the same command as before.\n\n## Woah! 😱\n\nThrough caching, we can ensure that we never do the same work twice. If you've built it before, we can simply use the build from last time instead of rebuilding again.\n\nHopefully, you're convinced that that was an awesome developer experience. Let's [start understanding the fundamentals](/monorepos/basics) now so you can build your own applications.",
    "_meta": {
      "filePath": "lessons/try-it-out/index.mdx",
      "fileName": "index.mdx",
      "directory": "lessons/try-it-out",
      "extension": "mdx",
      "path": "lessons/try-it-out"
    }
  },
  {
    "title": "Thinking in graphs",
    "sidebarOrderPosition": 0,
    "ogDescription": "The mental model for your monorepo",
    "content": "Thinking about your applications in the context of a monorepo is slightly different than working with a single application repository. When you have multiple workspaces in your repo, you'll want to thinking of your workspaces as associated with each other as a graph of dependencies and tasks.\n\nThis is important to stand depending on your role within the monorepo:\n\n- [As a repo maintainer](#as-a-repo-maintainer)\n- [As an application developer](#as-an-application-developer)\n\nNotably, you may only be one of these roles within your monorepo but it is still important to understand the concept of a [directed acyclic graph](https://en.wikipedia.org/wiki/Directed_acyclic_graph) (DAG) as you learn about how to use a monorepo. (We will be calling this simply \"a graph\" for short as we talk about this idea. No need to get hung up on the fancy words!)\n\n## Visualizing a monorepo graph\n\nCreating a mental picture of what a monorepo graph looks like is often a great way to get started with learning (and explaining!) how a monorepo connects workspaces and tasks together. As an example, let's take a look at the repository that holds this application, [some starter workspaces](/monorepos/tools), and \"Turbo Studio.\"\n\nFirst, clone the repository and install its dependencies:\n\n```bash filename=\"Terminal\" note=\"You will need pnpm installed on your machine to run this repository.\"\ngit clone https://github.com/anthonyshew/maestros\npnpm i\n```\n\nNext, run the command to build and start \"Turbo Studio\":\n\n```bash filename=\"Terminal\" note=\"We are using global Turbo here. You can install it with 'npm i -g turbo@latest' or add a script in the root of the repository with this command.\"\nturbo start:studio\n```\n\nYou should see a message that a Next.js app is now running at `localhost:3000`. When you visit, you'll get a graph that looks similar to this one.\n![Monorepo Graph](/images/maestros/maestros-in-studio.png)\n\nThis graph shows the steps that it takes to build Maestros:\n\n1. You or your CI run the `turbo build` pipeline.\n2. `turbo` finds the `maestros` app has a `build` task.\n3. `turbo` sees that the `build` task for the `maestros` workspace depends on the `generate` task. This dependency can be found in the root's `turbo.json`.\n\nThis is a simple pipeline with few steps. In the left sidebar, you can change the task to `turbo run lint` or `turbo run typecheck` see graphs with slightly more complexity. You can also edit `turbo.json` or workspace dependencies to see what changes you can bring to your task graph.\n\n### Using this visualization in your own repository\n\nYou can copy the \"Turbo Studio\" workspace into your project using [Turborepo Generators](https://turbo.build/repo/docs/core-concepts/monorepos/code-generation).\n\n```bash filename=\"Terminal\"\nturbo generate workspace -c https://github.com/anthonyshew/maestros/tree/main/apps/studio\n# > Follow the prompts. You don't need to install any workspace dependencies.\npnpm install # or your package manager\nturbo start:studio\n```\n\nVisit your browser and start inspecting your repository's graphs!\n\n### As a repo maintainer\n\nIf you're one of the folks entrusted with keeping the monorepo running smoothly, you'll want to keep your graph in mind as you work with the monorepo for a few reasons.\n\n- Making changes deep in your graph will affect the tasks that depend on that workspace. While you do want this to happen, you may want to consider if this will create an extra long build time that would slow up the pace of deployment for your developers. (This concern only seriously reveals itself at scale, where deployments can take considerable time to make it to production, even with Remote Caching enabled.)\n- The \"A\" in DAG stands for \"acylic\", meaning that you can't have Dependency A depend on Dependency B **and** Dependency B depending on Dependency A. If you create a cycle in your graph, `turbo` will throw an error because of this. You'll want to refactor your workspaces to alleviate this circle of dependencies.\n- A monorepo is a great way to encourage communication and collaboration on your company's products. As a keeper of the repository, your leadership on communication is vital to the success of all of the developers working within the repository. You can set a strong example of togetherness by working closely with the individuals and teams that work in the repo for everyone's benefit.\n\n### As an application developer\n\nIt's important to understand the characteristics of your graph as an application developer, as well.\n\n- Knowing the shared code that is available to you in your repository can save you considerable time when working on a feature. If your repository maintainers have, for example, created a shared error handling library for the whole company to use, you can import those functions and methods rather than having to create your own new error handlers.\n- Making changes in a workspace that is deep in the repo's graph could create a longer build time than you're expecting. Additionally, the workspace may also be a dependency in other applications, starting a build process for those applications, too. When you change shared code, your goal should be to overcommunicate those changes with anyone who may be affected in your engineering organization so everyone can stay on the same page.",
    "_meta": {
      "filePath": "lessons/try-it-out/thinking-in-graphs.mdx",
      "fileName": "thinking-in-graphs.mdx",
      "directory": "lessons/try-it-out",
      "extension": "mdx",
      "path": "lessons/try-it-out/thinking-in-graphs"
    }
  },
  {
    "title": "Understanding monorepos",
    "sidebarOrderPosition": 0,
    "ogDescription": "The basics of a monorepo",
    "content": "import { FileTree } from '#/components/FileTree';\n\n## What is a monorepo?\n\nA monorepo is a code repository that contains the source code for multiple applications and packages.\n\n<FileTree>\n  <FileTree.File name=\".gitignore\" />\n  <FileTree.File name=\"package.json\" />\n  <FileTree.File name=\"pnpm-lock.yaml\" />\n  <FileTree.File name=\"README.md\" />\n  <FileTree.Folder name=\"apps\" open>\n    <FileTree.Folder name=\"docs\" />\n    <FileTree.Folder name=\"mobile\" />\n    <FileTree.Folder name=\"web\" />\n  </FileTree.Folder>\n  <FileTree.Folder name=\"packages\" open>\n    <FileTree.Folder name=\"logger\" />\n    <FileTree.Folder name=\"ui\" />\n    <FileTree.Folder name=\"utils\" />\n  </FileTree.Folder>\n  <FileTree.Folder name=\"tooling\" open>\n    <FileTree.Folder name=\"eslint-config\" />\n    <FileTree.Folder name=\"prettier-config\" />\n  </FileTree.Folder>\n</FileTree>\n\nThere are more complex definitions that you can find out there but we're going to keep it simple. In a monorepo, you'll create organizational structures for your code where you can share \"packages\" to many applications. By bringing all of our code together, we give ourselves many opportunities for improved developer experience (DX), shipping velocity, and, because of that, better applications.\n\n### Improved discoverability\n\nReferences to source code will always be a quick Search or Go To Definition away rather than spread across various repositories. This lets you work faster, ship sooner, and have better clarity about what you're shipping.\n\n### One \"state of the world\"\n\nWhen you're working in a [polyrepo](/monorepos/glossary#polyrepo), you may have many different versions of the source code that make up your applications. Your CI/CD process becomes more complicated as you have to manage the orchestration of packages against each other, creating potential for edge cases and other unexpected difficulties.\n\nBut, in a monorepo, we can guarantee that changes are [atomic](/monorepos/glossary#atomic) and that we know _exactly_ what source code we are deploying. This simplicity lets us ship faster as we iterate over our applications and allows teams to work together much more quickly.\n\n### Faster than speed metal\n\nBuilding your applications takes time as your source code is compiled and/or bundled for delivery to users. As you continue iterating on your application, you'll end up compiling the same packages over and over again every time you need to redeploy.\n\nNOPE! Today's monorepo tools are built for making your workflow **fast** by **never doing the same work twice**. We'll create repositories that can get tasks done in **milliseconds** if the task has been done before.\n\n### A monorepo is not a monolith app\n\nA quick mental note: The various applications in your monorepo can (and should!) act independently of each other. For example, making changes to your web application doesn't have to (and shouldn't!) force your mobile application to redeploy.\n\nIn fact, **one** of your applications may be a monolith. In the case of [Next.js](https://nextjs.org), you can create a frontend and backend in the same application (a monolith!)\n\n<FileTree>\n  <FileTree.File name=\"package.json\" />\n  <FileTree.File name=\"pnpm-lock.yaml\" />\n  <FileTree.Folder name=\"apps\" open>\n    <FileTree.Folder name=\"nextjs (A monolith)\" />\n    <FileTree.Folder name=\"vite (A frontend)\" />\n    <FileTree.Folder name=\"express (A backend)\" />\n  </FileTree.Folder>\n</FileTree>\n\nThis application would deploy itself monolithically - but that doesn't make your whole monorepo into a monolith! You could just as easily create a Node.js backend to use with a Vite frontend. These two decoupled apps can work together when deployed. You could easily make edits to any one of your three apps without redeploying another.\n\nMaestros know how to build monorepos that do the least work possible on every commit to the repository. We'll learn how to isolate the pieces of our repository so that the workflows required to create deployments are high tempo, even at scale.\n\n## When to use a monorepo\n\nAs mentioned on [the Motivation page](/monorepos/motivation) for this resource, we're seeing monorepos are consistently proving their worth at all scales in today's software landscape. For that reason, you should think of a monorepo as your default and move away from a monorepo when it doesn't make sense.\n\n## Ready to make some music?\n\n[Head over to \"The basics\".](/monorepos/basics)",
    "_meta": {
      "filePath": "lessons/understanding-monorepos/index.mdx",
      "fileName": "index.mdx",
      "directory": "lessons/understanding-monorepos",
      "extension": "mdx",
      "path": "lessons/understanding-monorepos"
    }
  }
]